<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knight Test Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        .game-container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        #gameCanvas {
            border: 2px solid #34495e;
            border-radius: 5px;
            background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 60%, #228B22 60%, #228B22 100%);
        }
        
        .controls {
            color: white;
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
        }
        
        .controls div {
            margin: 5px 0;
        }
        
        .key {
            background: #34495e;
            padding: 3px 8px;
            border-radius: 3px;
            font-weight: bold;
        }
        
        .editor-panel {
            background: #2c3e50;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            color: white;
            font-size: 14px;
        }
        
        .editor-tools {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .tool-btn {
            background: #34495e;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .tool-btn:hover {
            background: #4a5a6a;
        }
        
        .tool-btn.active {
            background: #3498db;
        }
        
        .edit-mode-indicator {
            background: #e74c3c;
            color: white;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
            margin-bottom: 10px;
            display: inline-block;
        }
        
        .edit-instructions {
            font-size: 12px;
            color: #bdc3c7;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div class="controls">
            <div><span class="key">←→</span> 이동 | <span class="key">Space</span> 점프 | <span class="key">Z</span> 공격</div>
            <div><span class="key">S</span> 방어 | <span class="key">Shift</span> 대쉬 | <span class="key">E</span> 편집모드</div>
        </div>
        
        <div class="editor-panel" id="editorPanel" style="display: none;">
            <div class="edit-mode-indicator">맵 편집 모드</div>
            
            <div class="editor-tools">
                <button class="tool-btn active" onclick="selectTool('platform')">플랫폼</button>
                <button class="tool-btn" onclick="selectTool('monster')">몬스터</button>
                <button class="tool-btn" onclick="selectTool('delete')">삭제</button>
                <button class="tool-btn" onclick="clearMap()">맵 초기화</button>
                <button class="tool-btn" onclick="saveMap()">맵 저장</button>
                <button class="tool-btn" onclick="loadMap()">맵 불러오기</button>
            </div>
            
            <div class="edit-instructions">
                <div><strong>플랫폼 모드:</strong> 드래그해서 플랫폼 생성</div>
                <div><strong>몬스터 모드:</strong> 클릭해서 몬스터 배치</div>
                <div><strong>삭제 모드:</strong> 클릭해서 요소 삭제</div>
                <div><strong>단축키:</strong> E키로 편집모드 토글</div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // 게임 상태
        const gameState = {
            keys: {},
            lastTime: 0,
            gravity: 0.8,
            groundY: 500,
            editMode: false,
            selectedTool: 'platform',
            mouseX: 0,
            mouseY: 0,
            isDragging: false,
            dragStart: { x: 0, y: 0 }
        };
        
        // 맵 데이터
        const mapData = {
            platforms: [
                { x: 200, y: 400, width: 150, height: 20, type: 'platform' },
                { x: 400, y: 350, width: 150, height: 20, type: 'platform' },
                { x: 600, y: 300, width: 150, height: 20, type: 'platform' }
            ],
            spawnPoints: [
                { x: 100, y: 400, type: 'player' },
                { x: 400, y: 400, type: 'monster' },
                { x: 600, y: 400, type: 'monster' }
            ]
        };
        
        // 스프라이트 애니메이션 클래스
        class SpriteAnimation {
            constructor(imagePath, frameWidth, frameHeight, frameCount, frameRate = 10) {
                this.image = new Image();
                this.image.src = imagePath;
                this.frameWidth = frameWidth;
                this.frameHeight = frameHeight;
                this.frameCount = frameCount;
                this.frameRate = frameRate;
                this.currentFrame = 0;
                this.frameTimer = 0;
                this.isLoaded = false;
                
                this.image.onload = () => {
                    this.isLoaded = true;
                };
            }
            
            update(deltaTime) {
                if (!this.isLoaded) return;
                
                this.frameTimer += deltaTime;
                if (this.frameTimer >= 1000 / this.frameRate) {
                    this.currentFrame = (this.currentFrame + 1) % this.frameCount;
                    this.frameTimer = 0;
                }
            }
            
            draw(ctx, x, y, flipX = false) {
                if (!this.isLoaded) return;
                
                ctx.save();
                
                if (flipX) {
                    ctx.scale(-1, 1);
                    x = -x - this.frameWidth;
                }
                
                ctx.drawImage(
                    this.image,
                    this.currentFrame * this.frameWidth, 0,
                    this.frameWidth, this.frameHeight,
                    x, y,
                    this.frameWidth, this.frameHeight
                );
                
                ctx.restore();
            }
            
            reset() {
                this.currentFrame = 0;
                this.frameTimer = 0;
            }
        }
        
        // 나이트 플레이어 클래스
        class Knight {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 100;
                this.height = 64;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 5;
                this.jumpPower = 15;
                this.facingRight = true;
                this.onGround = false;
                this.state = 'idle';
                this.attackTimer = 0;
                this.dashTimer = 0;
                this.shieldTimer = 0;
                this.attackCombo = 0;
                this.comboTimer = 0;
                this.isAttacking = false;
                this.isDashing = false;
                
                // 애니메이션 로드 (추정 프레임 수)
                this.animations = {
                    idle: new SpriteAnimation('../../Knight_Player/Idle_KG_1.png', 100, 64, 4, 6),
                    walking: new SpriteAnimation('../../Knight_Player/Walking_KG_1.png', 100, 64, 8, 12),
                    jump: new SpriteAnimation('../../Knight_Player/Jump_KG_1.png', 100, 64, 3, 8),
                    attack1: new SpriteAnimation('../../Knight_Player/Attack_KG_1.png', 100, 64, 4, 18),
                    attack2: new SpriteAnimation('../../Knight_Player/Attack_KG_2.png', 100, 64, 6, 18),
                    attack3: new SpriteAnimation('../../Knight_Player/Attack_KG_3.png', 100, 64, 8, 18),
                    shield: new SpriteAnimation('../../Knight_Player/Shield_idle_KG.png', 100, 64, 2, 6),
                    rolling: new SpriteAnimation('../../Knight_Player/Rolling_KG_1.png', 100, 64, 12, 20),
                    hurt: new SpriteAnimation('../../Knight_Player/Hurt_KG_1.png', 100, 64, 2, 8)
                };
                
                this.currentAnimation = this.animations.idle;
            }
            
            update(deltaTime) {
                // 타이머 업데이트
                if (this.attackTimer > 0) this.attackTimer -= deltaTime;
                if (this.dashTimer > 0) this.dashTimer -= deltaTime;
                if (this.shieldTimer > 0) this.shieldTimer -= deltaTime;
                if (this.comboTimer > 0) this.comboTimer -= deltaTime;
                
                // 콤보 타이머가 끝나면 콤보 리셋
                if (this.comboTimer <= 0 && this.attackCombo > 0) {
                    this.attackCombo = 0;
                }
                
                // 공격 애니메이션이 끝났는지 체크
                if (this.isAttacking && this.attackTimer <= 0) {
                    this.isAttacking = false;
                    this.state = 'idle';
                }
                
                // 입력 처리
                this.handleInput();
                
                // 물리 업데이트
                this.updatePhysics();
                
                // 상태 업데이트
                this.updateState();
                
                // 애니메이션 업데이트
                this.currentAnimation.update(deltaTime);
            }
            
            handleInput() {
                // 공격 중이면 이동 제한 (콤보 공격 제외)
                if (this.isAttacking && this.attackTimer > 200) return;
                
                // 방어
                if (gameState.keys['KeyS'] && !this.isAttacking) {
                    this.state = 'shield';
                    this.shieldTimer = 100;
                    return;
                }
                
                // 대쉬 (쿨다운과 더 자연스러운 조건)
                if (gameState.keys['ShiftLeft'] && this.dashTimer <= 0 && !this.isAttacking && this.onGround && !this.isDashing) {
                    this.state = 'rolling';
                    this.dashTimer = 1000;
                    this.velocityX = this.facingRight ? 15 : -15;
                    this.isAttacking = false;
                    this.isDashing = true;
                    this.animations.rolling.reset(); // 애니메이션 리셋
                    return;
                }
                
                // 콤보 공격 시스템
                if (gameState.keys['KeyZ'] && this.attackTimer <= 0) {
                    this.performAttack();
                    return;
                }
                
                // 공격 중이 아닐 때만 이동 가능
                if (!this.isAttacking) {
                    // 이동
                    if (gameState.keys['ArrowLeft']) {
                        this.velocityX = -this.speed;
                        this.facingRight = false;
                        if (this.onGround && this.state !== 'rolling') this.state = 'walking';
                    } else if (gameState.keys['ArrowRight']) {
                        this.velocityX = this.speed;
                        this.facingRight = true;
                        if (this.onGround && this.state !== 'rolling') this.state = 'walking';
                    } else {
                        this.velocityX = 0;
                        if (this.onGround && this.state !== 'rolling' && this.state !== 'shield') this.state = 'idle';
                    }
                    
                    // 점프
                    if (gameState.keys['Space'] && this.onGround) {
                        this.velocityY = -this.jumpPower;
                        this.onGround = false;
                        this.state = 'jump';
                    }
                }
            }
            
            performAttack() {
                // 콤보 시스템
                if (this.comboTimer > 0) {
                    this.attackCombo = (this.attackCombo % 3) + 1;
                } else {
                    this.attackCombo = 1;
                }
                
                // 콤보 타이머 리셋 (1.5초 내에 다음 공격 입력 시 콤보 연결)
                this.comboTimer = 1500;
                
                // 공격 상태 설정
                this.state = 'attack';
                this.isAttacking = true;
                
                // 공격별 다른 타이머 설정
                switch(this.attackCombo) {
                    case 1:
                        this.attackTimer = 400;
                        break;
                    case 2:
                        this.attackTimer = 500;
                        break;
                    case 3:
                        this.attackTimer = 700;
                        break;
                }
                
                // 공격 시 약간 앞으로 이동
                this.velocityX = this.facingRight ? 2 : -2;
                
                // 몬스터 공격 처리
                this.checkAttackHit();
            }
            
            checkAttackHit() {
                const attackRange = this.getAttackRange();
                
                monsters.forEach(monster => {
                    if (monster.isDead) return;
                    
                    const monsterBounds = monster.getBounds();
                    
                    // 충돌 감지
                    if (attackRange.x < monsterBounds.x + monsterBounds.width &&
                        attackRange.x + attackRange.width > monsterBounds.x &&
                        attackRange.y < monsterBounds.y + monsterBounds.height &&
                        attackRange.y + attackRange.height > monsterBounds.y) {
                        
                        // 데미지 계산 (콤보에 따라 다름)
                        let damage = 25;
                        if (this.attackCombo === 2) damage = 30;
                        if (this.attackCombo === 3) damage = 40;
                        
                        monster.takeDamage(damage);
                        
                        // 넉백 효과
                        const knockbackForce = this.facingRight ? 5 : -5;
                        monster.velocityX = knockbackForce;
                    }
                });
            }
            
            updatePhysics() {
                // 중력 적용
                if (!this.onGround) {
                    this.velocityY += gameState.gravity;
                }
                
                // 위치 업데이트
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // 화면 경계 체크
                if (this.x < 0) this.x = 0;
                if (this.x > canvas.width - this.width) this.x = canvas.width - this.width;
                
                // 바닥 충돌
                if (this.y > gameState.groundY - this.height) {
                    this.y = gameState.groundY - this.height;
                    this.velocityY = 0;
                    this.onGround = true;
                    
                    if (this.state === 'jump') {
                        this.state = 'idle';
                    }
                }
                
                // 플랫폼 충돌
                this.checkPlatformCollisions();
                
                // 대쉬 중 마찰과 감속
                if (this.isDashing && this.state === 'rolling') {
                    this.velocityX *= 0.92;
                    // 대쉬 애니메이션이 끝나면 대쉬 종료
                    if (this.animations.rolling.currentFrame >= this.animations.rolling.frameCount - 1) {
                        this.isDashing = false;
                        this.state = 'idle';
                    }
                } else if (!this.isAttacking && this.onGround) {
                    // 일반 상태에서 마찰 적용
                    this.velocityX *= 0.85;
                }
                
                // 공격 중 미세한 감속
                if (this.isAttacking && this.onGround) {
                    this.velocityX *= 0.9;
                }
            }
            
            updateState() {
                // 공중에 있으면 점프 상태 (공격 중이 아닐 때만)
                if (!this.onGround && this.state !== 'jump' && !this.isAttacking) {
                    this.state = 'jump';
                }
                
                // 애니메이션 변경
                let newAnimation = this.animations[this.state];
                
                // 공격 상태 세분화 (콤보 시스템)
                if (this.state === 'attack') {
                    switch(this.attackCombo) {
                        case 1:
                            newAnimation = this.animations.attack1;
                            break;
                        case 2:
                            newAnimation = this.animations.attack2;
                            break;
                        case 3:
                            newAnimation = this.animations.attack3;
                            break;
                        default:
                            newAnimation = this.animations.attack1;
                    }
                }
                
                if (this.currentAnimation !== newAnimation) {
                    this.currentAnimation = newAnimation;
                    this.currentAnimation.reset();
                }
            }
            
            draw(ctx) {
                // 바닥 그림자만 그리기
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x + this.width/2, gameState.groundY + 5, this.width/3, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 캐릭터 그리기
                this.currentAnimation.draw(ctx, this.x, this.y, !this.facingRight);
                
                // 디버그 정보
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(`State: ${this.state}`, 10, 30);
                ctx.fillText(`Position: ${Math.floor(this.x)}, ${Math.floor(this.y)}`, 10, 50);
                ctx.fillText(`Velocity: ${Math.floor(this.velocityX)}, ${Math.floor(this.velocityY)}`, 10, 70);
                ctx.fillText(`On Ground: ${this.onGround}`, 10, 90);
                ctx.fillText(`Attack Combo: ${this.attackCombo}`, 10, 110);
                ctx.fillText(`Combo Timer: ${Math.floor(this.comboTimer)}ms`, 10, 130);
                ctx.fillText(`Dashing: ${this.isDashing}`, 10, 150);
                
                // 몬스터 정보
                const aliveMonsters = monsters.filter(m => !m.isDead).length;
                ctx.fillText(`Monsters Alive: ${aliveMonsters}`, 10, 170);
                
                // 편집 모드 정보
                if (gameState.editMode) {
                    ctx.fillText(`Edit Mode: ${gameState.selectedTool}`, 10, 190);
                    ctx.fillText(`Mouse: ${Math.floor(gameState.mouseX)}, ${Math.floor(gameState.mouseY)}`, 10, 210);
                }
            }
            
            // 플랫폼 충돌 체크
            checkPlatformCollisions() {
                mapData.platforms.forEach(platform => {
                    // 충돌 감지
                    if (this.x < platform.x + platform.width &&
                        this.x + this.width > platform.x &&
                        this.y < platform.y + platform.height &&
                        this.y + this.height > platform.y) {
                        
                        // 위에서 떨어지는 경우 (발판 위에 서기)
                        if (this.velocityY > 0 && this.y < platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                            
                            if (this.state === 'jump') {
                                this.state = 'idle';
                            }
                        }
                        // 아래에서 올라오는 경우 (천장 충돌)
                        else if (this.velocityY < 0 && this.y > platform.y) {
                            this.y = platform.y + platform.height;
                            this.velocityY = 0;
                        }
                        // 옆에서 충돌하는 경우
                        else if (this.velocityX > 0 && this.x < platform.x) {
                            this.x = platform.x - this.width;
                            this.velocityX = 0;
                        }
                        else if (this.velocityX < 0 && this.x > platform.x) {
                            this.x = platform.x + platform.width;
                            this.velocityX = 0;
                        }
                    }
                });
            }
            
            // 공격 범위 체크
            getAttackRange() {
                const range = 80;
                const attackX = this.facingRight ? this.x + this.width : this.x - range;
                return {
                    x: attackX,
                    y: this.y,
                    width: range,
                    height: this.height
                };
            }
        }
        
        // 몬스터 클래스
        class Monster {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 60;
                this.velocityX = 0;
                this.velocityY = 0;
                this.speed = 1;
                this.facingRight = false;
                this.onGround = false;
                this.health = 100;
                this.maxHealth = 100;
                this.isDead = false;
                this.hitTimer = 0;
                this.patrolDistance = 150;
                this.startX = x;
                this.patrolDirection = 1;
                
                // 간단한 애니메이션 (색상 변화로 대체)
                this.animationFrame = 0;
                this.animationTimer = 0;
            }
            
            update(deltaTime) {
                if (this.isDead) return;
                
                // 타이머 업데이트
                if (this.hitTimer > 0) this.hitTimer -= deltaTime;
                
                // 애니메이션 업데이트
                this.animationTimer += deltaTime;
                if (this.animationTimer >= 500) {
                    this.animationFrame = (this.animationFrame + 1) % 4;
                    this.animationTimer = 0;
                }
                
                // AI 패트롤
                this.patrol();
                
                // 물리 업데이트
                this.updatePhysics();
                
                // 플레이어와의 거리 체크 (공격 감지)
                this.checkPlayerDistance();
            }
            
            patrol() {
                // 패트롤 이동
                if (Math.abs(this.x - this.startX) >= this.patrolDistance) {
                    this.patrolDirection *= -1;
                }
                
                this.velocityX = this.speed * this.patrolDirection;
                this.facingRight = this.patrolDirection > 0;
            }
            
            updatePhysics() {
                // 중력 적용
                if (!this.onGround) {
                    this.velocityY += gameState.gravity;
                }
                
                // 위치 업데이트
                this.x += this.velocityX;
                this.y += this.velocityY;
                
                // 화면 경계 체크
                if (this.x < 0) {
                    this.x = 0;
                    this.patrolDirection *= -1;
                }
                if (this.x > canvas.width - this.width) {
                    this.x = canvas.width - this.width;
                    this.patrolDirection *= -1;
                }
                
                // 바닥 충돌
                if (this.y > gameState.groundY - this.height) {
                    this.y = gameState.groundY - this.height;
                    this.velocityY = 0;
                    this.onGround = true;
                }
                
                // 플랫폼 충돌 (몬스터용)
                this.checkPlatformCollisions();
            }
            
            checkPlayerDistance() {
                const distance = Math.abs(this.x - knight.x);
                if (distance < 200) {
                    // 플레이어 쪽으로 이동
                    this.patrolDirection = knight.x > this.x ? 1 : -1;
                    this.speed = 2;
                } else {
                    this.speed = 1;
                }
            }
            
            takeDamage(damage) {
                if (this.hitTimer > 0 || this.isDead) return;
                
                this.health -= damage;
                this.hitTimer = 500; // 0.5초 무적
                
                if (this.health <= 0) {
                    this.isDead = true;
                    this.health = 0;
                }
            }
            
            draw(ctx) {
                if (this.isDead) return;
                
                // 몬스터 그림자
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x + this.width/2, gameState.groundY + 5, this.width/3, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // 몬스터 몸체 (간단한 도형으로 표현)
                ctx.save();
                
                // 피격 시 깜빡임
                if (this.hitTimer > 0 && Math.floor(this.hitTimer / 100) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }
                
                // 몬스터 색상 (애니메이션)
                const colors = ['#8B0000', '#A52A2A', '#DC143C', '#B22222'];
                ctx.fillStyle = colors[this.animationFrame];
                
                // 몬스터 몸체
                ctx.fillRect(this.x, this.y, this.width, this.height);
                
                // 눈
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 10, this.y + 10, 12, 12);
                ctx.fillRect(this.x + 38, this.y + 10, 12, 12);
                
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 14, this.y + 14, 4, 4);
                ctx.fillRect(this.x + 42, this.y + 14, 4, 4);
                
                ctx.restore();
                
                // 체력바
                this.drawHealthBar(ctx);
            }
            
            drawHealthBar(ctx) {
                const barWidth = this.width;
                const barHeight = 6;
                const barX = this.x;
                const barY = this.y - 15;
                
                // 체력바 배경
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // 체력바
                ctx.fillStyle = this.health > 30 ? '#00FF00' : '#FF0000';
                const healthPercent = this.health / this.maxHealth;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // 체력바 테두리
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }
            
            // 충돌 감지
            getBounds() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                };
            }
            
            // 몬스터 플랫폼 충돌 체크
            checkPlatformCollisions() {
                mapData.platforms.forEach(platform => {
                    if (this.x < platform.x + platform.width &&
                        this.x + this.width > platform.x &&
                        this.y < platform.y + platform.height &&
                        this.y + this.height > platform.y) {
                        
                        // 위에서 떨어지는 경우만 처리 (몬스터는 간단하게)
                        if (this.velocityY > 0 && this.y < platform.y) {
                            this.y = platform.y - this.height;
                            this.velocityY = 0;
                            this.onGround = true;
                        }
                    }
                });
            }
        }
        
        // 편집 모드 UI 그리기
        function drawEditModeUI() {
            // 그리드 그리기
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            // 세로선
            for (let x = 0; x < canvas.width; x += 50) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // 가로선
            for (let y = 0; y < canvas.height; y += 50) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // 마우스 커서 표시
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(gameState.mouseX, gameState.mouseY, 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // 도구별 미리보기
            if (gameState.selectedTool === 'platform' && gameState.isDragging) {
                // 플랫폼 드래그 미리보기
                const width = Math.abs(gameState.mouseX - gameState.dragStart.x);
                const height = Math.abs(gameState.mouseY - gameState.dragStart.y);
                const x = Math.min(gameState.mouseX, gameState.dragStart.x);
                const y = Math.min(gameState.mouseY, gameState.dragStart.y);
                
                ctx.fillStyle = 'rgba(101, 67, 33, 0.5)';
                ctx.fillRect(x, y, width, height);
                
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
            }
            
            // 몬스터 배치 미리보기
            if (gameState.selectedTool === 'monster') {
                ctx.fillStyle = 'rgba(139, 0, 0, 0.5)';
                ctx.fillRect(gameState.mouseX - 30, gameState.mouseY - 30, 60, 60);
                
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(gameState.mouseX - 30, gameState.mouseY - 30, 60, 60);
            }
            
            // 삭제 모드 표시
            if (gameState.selectedTool === 'delete') {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(gameState.mouseX - 15, gameState.mouseY - 15);
                ctx.lineTo(gameState.mouseX + 15, gameState.mouseY + 15);
                ctx.moveTo(gameState.mouseX + 15, gameState.mouseY - 15);
                ctx.lineTo(gameState.mouseX - 15, gameState.mouseY + 15);
                ctx.stroke();
            }
        }
        
        // 게임 객체 생성
        const knight = new Knight(100, 400);
        let monsters = [
            new Monster(400, 400),
            new Monster(600, 400)
        ];
        
        // 맵 에디터 함수들
        function toggleEditMode() {
            gameState.editMode = !gameState.editMode;
            const panel = document.getElementById('editorPanel');
            panel.style.display = gameState.editMode ? 'block' : 'none';
            
            if (gameState.editMode) {
                console.log('편집 모드 활성화');
            } else {
                console.log('편집 모드 비활성화');
            }
        }
        
        function selectTool(tool) {
            gameState.selectedTool = tool;
            
            // 버튼 활성화 상태 업데이트
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            event.target.classList.add('active');
        }
        
        function clearMap() {
            if (confirm('정말 맵을 초기화하시겠습니까?')) {
                mapData.platforms = [];
                monsters = [];
                console.log('맵 초기화됨');
            }
        }
        
        function saveMap() {
            const mapJson = JSON.stringify(mapData, null, 2);
            const blob = new Blob([mapJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'knight-map.json';
            a.click();
            
            URL.revokeObjectURL(url);
            console.log('맵 저장됨');
        }
        
        function loadMap() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const loadedMap = JSON.parse(e.target.result);
                            mapData.platforms = loadedMap.platforms || [];
                            
                            // 몬스터 재생성
                            monsters = [];
                            if (loadedMap.spawnPoints) {
                                loadedMap.spawnPoints.forEach(spawn => {
                                    if (spawn.type === 'monster') {
                                        monsters.push(new Monster(spawn.x, spawn.y));
                                    }
                                });
                            }
                            
                            console.log('맵 불러오기 완료');
                        } catch (error) {
                            alert('맵 파일을 불러오는데 실패했습니다.');
                            console.error(error);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }
        
        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            };
        }
        
        function handleCanvasClick(e) {
            if (!gameState.editMode) return;
            
            const pos = getMousePos(e);
            
            switch (gameState.selectedTool) {
                case 'monster':
                    // 몬스터 배치
                    monsters.push(new Monster(pos.x, pos.y));
                    mapData.spawnPoints.push({ x: pos.x, y: pos.y, type: 'monster' });
                    break;
                    
                case 'delete':
                    // 삭제 모드
                    deleteElementAt(pos.x, pos.y);
                    break;
            }
        }
        
        function handleCanvasMouseDown(e) {
            if (!gameState.editMode || gameState.selectedTool !== 'platform') return;
            
            const pos = getMousePos(e);
            gameState.isDragging = true;
            gameState.dragStart = pos;
        }
        
        function handleCanvasMouseUp(e) {
            if (!gameState.editMode || !gameState.isDragging) return;
            
            const pos = getMousePos(e);
            const width = Math.abs(pos.x - gameState.dragStart.x);
            const height = Math.abs(pos.y - gameState.dragStart.y);
            
            if (width > 10 && height > 10) {
                const platform = {
                    x: Math.min(pos.x, gameState.dragStart.x),
                    y: Math.min(pos.y, gameState.dragStart.y),
                    width: width,
                    height: height,
                    type: 'platform'
                };
                
                mapData.platforms.push(platform);
            }
            
            gameState.isDragging = false;
        }
        
        function handleCanvasMouseMove(e) {
            const pos = getMousePos(e);
            gameState.mouseX = pos.x;
            gameState.mouseY = pos.y;
        }
        
        function deleteElementAt(x, y) {
            // 플랫폼 삭제
            mapData.platforms = mapData.platforms.filter(platform => {
                return !(x >= platform.x && x <= platform.x + platform.width &&
                        y >= platform.y && y <= platform.y + platform.height);
            });
            
            // 몬스터 삭제
            for (let i = monsters.length - 1; i >= 0; i--) {
                const monster = monsters[i];
                if (x >= monster.x && x <= monster.x + monster.width &&
                    y >= monster.y && y <= monster.y + monster.height) {
                    monsters.splice(i, 1);
                    break;
                }
            }
        }
        
        // 키보드 이벤트
        document.addEventListener('keydown', (e) => {
            gameState.keys[e.code] = true;
            
            // 편집 모드 토글
            if (e.code === 'KeyE') {
                toggleEditMode();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            gameState.keys[e.code] = false;
        });
        
        // 마우스 이벤트
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        
        // 게임 루프
        function gameLoop(currentTime) {
            const deltaTime = currentTime - gameState.lastTime;
            gameState.lastTime = currentTime;
            
            // 화면 지우기
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 배경 그리기
            drawBackground();
            
            // 플랫폼 그리기
            drawPlatforms();
            
            // 나이트 업데이트 및 그리기
            knight.update(deltaTime);
            knight.draw(ctx);
            
            // 몬스터 업데이트 및 그리기
            monsters.forEach(monster => {
                monster.update(deltaTime);
                monster.draw(ctx);
            });
            
            // 공격 범위 시각화 (디버그용)
            if (knight.isAttacking) {
                const attackRange = knight.getAttackRange();
                ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(attackRange.x, attackRange.y, attackRange.width, attackRange.height);
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        function drawBackground() {
            // 하늘 그라데이션
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#87CEEB');
            gradient.addColorStop(0.6, '#87CEEB');
            gradient.addColorStop(0.6, '#228B22');
            gradient.addColorStop(1, '#228B22');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 구름 그리기
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const x = (i * 200) + 50;
                const y = 50 + Math.sin(Date.now() * 0.001 + i) * 10;
                
                ctx.beginPath();
                ctx.arc(x, y, 30, 0, Math.PI * 2);
                ctx.arc(x + 25, y, 35, 0, Math.PI * 2);
                ctx.arc(x + 50, y, 30, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawPlatforms() {
            // 메인 바닥
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, gameState.groundY, canvas.width, canvas.height - gameState.groundY);
            
            // 잔디
            ctx.fillStyle = '#228B22';
            ctx.fillRect(0, gameState.groundY - 10, canvas.width, 10);
            
            // 동적 플랫폼들 그리기
            mapData.platforms.forEach(platform => {
                // 플랫폼 본체
                ctx.fillStyle = '#654321';
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // 플랫폼 하이라이트
                ctx.fillStyle = '#8B4513';
                ctx.fillRect(platform.x, platform.y, platform.width, Math.min(5, platform.height));
                
                // 편집 모드에서 테두리 표시
                if (gameState.editMode) {
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
                }
            });
            
            // 편집 모드 시각화
            if (gameState.editMode) {
                drawEditModeUI();
            }
        }
        
        // 게임 시작
        requestAnimationFrame(gameLoop);
        
        // 로딩 상태 표시
        ctx.fillStyle = 'white';
        ctx.font = '24px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Loading Knight Assets...', canvas.width/2, canvas.height/2);
        ctx.textAlign = 'left';
    </script>
</body>
</html> 