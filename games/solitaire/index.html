<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†”ë¦¬í…Œì–´</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="mobile-landscape-notice">
        <div class="notice-content">
            <div class="rotate-icon">ğŸ“±</div>
            <p>ëª¨ë°”ì¼ì—ì„œëŠ” ê°€ë¡œë¡œ í”Œë ˆì´í•´ì£¼ì„¸ìš”!</p>
        </div>
    </div>

    <div class="container">
        <div class="game-header">
            <a href="../../index.html" class="back-btn">â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
            
            <div class="game-center">
                <h1 class="game-title">ğŸƒ ì†”ë¦¬í…Œì–´ í´ë˜ì‹</h1>
                <div class="game-info">
                    <div class="score">ì ìˆ˜: <span id="score">0</span></div>
                    <div class="time">ì‹œê°„: <span id="time">00:00</span></div>
                    <div class="moves">ì›€ì§ì„: <span id="moves">0</span></div>
                </div>
            </div>
            
            <div class="controls">
                <button class="btn" onclick="newGame()">ìƒˆ ê²Œì„</button>
            </div>
        </div>

        <div class="game-container">
            <!-- í†µí•©ëœ ê²Œì„ ì˜ì—­ -->
            <div class="game-area">
                <!-- ìƒë‹¨ ì˜ì—­: ë±ê³¼ íŒŒìš´ë°ì´ì…˜ -->
                <div class="top-area">
                    <div class="deck-area">
                        <div class="card-slot" id="stock" onclick="drawCard()">
                        </div>
                        <div class="card-slot" id="waste"></div>
                    </div>
                    
                    <div class="foundation-area">
                        <div class="card-slot foundation" data-suit="hearts">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™¥</div>
                        </div>
                        <div class="card-slot foundation" data-suit="diamonds">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™¦</div>
                        </div>
                        <div class="card-slot foundation" data-suit="clubs">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™£</div>
                        </div>
                        <div class="card-slot foundation" data-suit="spades">
                            <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™ </div>
                        </div>
                    </div>
                </div>

                <!-- í•˜ë‹¨ ì˜ì—­: 7ê°œ ì»¬ëŸ¼ -->
                <div class="tableau-area">
                    <div class="column" data-column="0"></div>
                    <div class="column" data-column="1"></div>
                    <div class="column" data-column="2"></div>
                    <div class="column" data-column="3"></div>
                    <div class="column" data-column="4"></div>
                    <div class="column" data-column="5"></div>
                    <div class="column" data-column="6"></div>
                </div>
            </div>
        </div>

        <!-- ìŠ¹ë¦¬ ëª¨ë‹¬ -->
        <div class="win-modal" id="winModal">
            <div class="win-content">
                <div class="win-title">ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰</div>
                <div class="win-stats">
                    <div>ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span>ì </div>
                    <div>í”Œë ˆì´ ì‹œê°„: <span id="finalTime">00:00</span></div>
                    <div>ì´ ì›€ì§ì„: <span id="finalMoves">0</span>ë²ˆ</div>
                </div>
                <button class="btn" onclick="closeWinModal()" style="margin: 10px; font-size: 1.1rem; padding: 12px 20px;">ê³„ì†í•˜ê¸°</button>
                <button class="btn" onclick="newGame(); closeWinModal();" style="margin: 10px; font-size: 1.1rem; padding: 12px 20px;">ìƒˆ ê²Œì„</button>
            </div>
        </div>

        <script>
            // ê²Œì„ ìƒíƒœ
            let deck = [];
            let stock = [];
            let waste = [];
            let foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
            let tableau = [[], [], [], [], [], [], []];
            let score = 0;
            let moves = 0;
            let startTime = Date.now();
            let gameWon = false;
            let draggedCard = null;
            let draggedFrom = null;
            let drawCount = 0; // ë½‘ê¸° íšŸìˆ˜ ì¶”ì 
            
            // ë”ë¸”í´ë¦­ ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ (ì¤‘ë³µ ë°©ì§€)
            let isProcessingDoubleClick = false;
            
            // ì‹¤í–‰ ì·¨ì†Œ ì‹œìŠ¤í…œ
            let gameHistory = [];
            let maxHistorySize = 50;
            
            // ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ë°©ì§€
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // ê²Œì„ ìƒíƒœ ì €ì¥
            function saveGameState() {
                const gameState = {
                    stock: JSON.parse(JSON.stringify(stock)),
                    waste: JSON.parse(JSON.stringify(waste)),
                    foundations: JSON.parse(JSON.stringify(foundations)),
                    tableau: JSON.parse(JSON.stringify(tableau)),
                    score: score,
                    moves: moves,
                    drawCount: drawCount
                };
                
                gameHistory.push(gameState);
                
                // íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
                if (gameHistory.length > maxHistorySize) {
                    gameHistory.shift();
                }
            }
            
            // ì‹¤í–‰ ì·¨ì†Œ
            function undoMove() {
                if (gameHistory.length === 0) return;
                
                const previousState = gameHistory.pop();
                
                stock = previousState.stock;
                waste = previousState.waste;
                foundations = previousState.foundations;
                tableau = previousState.tableau;
                score = previousState.score;
                moves = previousState.moves;
                drawCount = previousState.drawCount;
                
                isProcessingDoubleClick = false; // ë”ë¸”í´ë¦­ í”Œë˜ê·¸ ì´ˆê¸°í™”
                
                renderGame();
            }
            
            // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    undoMove();
                }
                if (e.key === 'F2') {
                    e.preventDefault();
                    newGame();
                }
            });
            
            // ì ìˆ˜ ì¦ê°€ ì• ë‹ˆë©”ì´ì…˜
            function animateScoreIncrease(points) {
                const scoreEl = document.querySelector('.score');
                scoreEl.classList.remove('score-update');
                void scoreEl.offsetWidth; // ê°•ì œ ë¦¬í”Œë¡œìš°
                scoreEl.classList.add('score-update');
            }

            // íƒ€ë¸”ë¡œ ì¹´ë“œ ë”ë¸”í´ë¦­/ë”ë¸”íƒ­ ì²˜ë¦¬ í•¨ìˆ˜
            function handleTableauCardDoubleClick(card, col, index, cardEl) {
                // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
                if (isProcessingDoubleClick) {
                    return;
                }
                
                // í˜„ì¬ ì¹´ë“œê°€ ì—¬ì „íˆ í•´ë‹¹ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
                if (tableau[col].length <= index || tableau[col][index] !== card) {
                    return;
                }
                
                // ë§¨ ìœ„ ì¹´ë“œì¸ì§€ ë‹¤ì‹œ í™•ì¸
                if (index !== tableau[col].length - 1) {
                    return;
                }
                
                if (!card || !card.suit || !card.rank) {
                    return;
                }
                
                if (canPlaceOnFoundation(card, card.suit)) {
                    isProcessingDoubleClick = true; // ì²˜ë¦¬ ì‹œì‘
                    const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì´ë™
                    animateCardMove(cardEl, targetFoundation, () => {
                        // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì‹œì ì— ë‹¤ì‹œ í•œ ë²ˆ í™•ì¸
                        if (tableau[col].length > index && tableau[col][index] === card) {
                            saveGameState();
                            tableau[col].splice(index, 1);
                            
                            // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                            if (tableau[col].length > 0) {
                                const lastCard = tableau[col][tableau[col].length - 1];
                                if (!lastCard.faceUp) {
                                    lastCard.faceUp = true;
                                    score += 5;
                                }
                            }
                            
                            foundations[card.suit].push(card);
                            moves++;
                            score += 10;
                            animateScoreIncrease(10);
                            renderGame();
                            checkWin();
                            checkAutoComplete();
                        }
                        isProcessingDoubleClick = false; // ì²˜ë¦¬ ì™„ë£Œ
                    });
                }
            }

            // ì¹´ë“œ ìƒì„±
            function createDeck() {
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                const ranks = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king'];
                deck = [];

                for (let suit of suits) {
                    for (let rank of ranks) {
                        deck.push({
                            suit: suit,
                            rank: rank,
                            value: rank === 'ace' ? 1 : 
                                   rank === 'jack' ? 11 : 
                                   rank === 'queen' ? 12 : 
                                   rank === 'king' ? 13 : 
                                   parseInt(rank),
                            color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                            faceUp: false
                        });
                    }
                }
            }

            // ë± ì„ê¸°
            function shuffleDeck() {
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }
            }

            // ì¹´ë“œ ìš”ì†Œ ìƒì„± (ìµœì í™”)
            function createCardElement(card) {
                if (!card || !card.suit || !card.rank) return null;
                
                const cardEl = document.createElement('div');
                cardEl.className = `card ${card.color}`;
                cardEl.draggable = true;
                
                if (card.faceUp) {
                    const imagePath = `./cards/${card.suit}-${card.rank}.png`;
                    cardEl.style.backgroundImage = `url('${imagePath}')`;
                    cardEl.style.backgroundSize = 'cover';
                    cardEl.classList.add('with-image');
                    cardEl.innerHTML = '';
                } else {
                    cardEl.classList.add('face-down', 'with-image');
                    cardEl.style.backgroundImage = `url('./cards/back.png')`;
                    cardEl.style.backgroundSize = 'cover';
                    cardEl.innerHTML = '';
                }

                cardEl.addEventListener('dragstart', handleDragStart);
                cardEl.addEventListener('click', handleCardClick);
                cardEl.addEventListener('mousedown', handleCardClick);
                
                return cardEl;
            }

            // ì¹´ë“œ í‘œì‹œ ë­í¬
            function getDisplayRank(rank) {
                switch(rank) {
                    case 'ace': return 'A';
                    case 'jack': return 'J';
                    case 'queen': return 'Q';
                    case 'king': return 'K';
                    default: return rank;
                }
            }

            // ìˆ˜íŠ¸ ì‹¬ë³¼
            function getSuitSymbol(suit) {
                switch(suit) {
                    case 'hearts': return 'â™¥';
                    case 'diamonds': return 'â™¦';
                    case 'clubs': return 'â™£';
                    case 'spades': return 'â™ ';
                    default: return suit;
                }
            }

            // ê²Œì„ í•´ê²° ê°€ëŠ¥ì„± ì²´í¬
            function checkGameSolvability() {
                let solvabilityScore = 0;
                let issues = [];
                
                // 1. ì—ì´ìŠ¤ë“¤ì˜ ì ‘ê·¼ì„± ì²´í¬
                const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
                let accessibleAces = 0;
                
                suits.forEach(suit => {
                    // íƒ€ë¸”ë¡œ ë§¨ ìœ„ ì¹´ë“œë“¤ì—ì„œ ì—ì´ìŠ¤ ì°¾ê¸°
                    for (let col = 0; col < 7; col++) {
                        if (tableau[col].length > 0) {
                            const topCard = tableau[col][tableau[col].length - 1];
                            if (topCard.rank === 'ace' && topCard.suit === suit) {
                                accessibleAces++;
                                solvabilityScore += 25;
                            }
                        }
                    }
                    
                    // ìŠ¤í†¡/ì›¨ì´ìŠ¤íŠ¸ì—ì„œ ì—ì´ìŠ¤ ì°¾ê¸° (ì¶”ê°€ ì ìˆ˜)
                    const stockHasAce = stock.some(card => card.rank === 'ace' && card.suit === suit);
                    const wasteHasAce = waste.some(card => card.rank === 'ace' && card.suit === suit);
                    if (stockHasAce || wasteHasAce) {
                        solvabilityScore += 15;
                    }
                });
                
                // 2. ê¸°ë³¸ ì´ë™ ê°€ëŠ¥ì„± ì²´í¬
                let possibleMoves = 0;
                
                // íƒ€ë¸”ë¡œ ê°„ ì´ë™ ê°€ëŠ¥ì„±
                for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
                    if (tableau[sourceCol].length > 0) {
                        const sourceCard = tableau[sourceCol][tableau[sourceCol].length - 1];
                        if (sourceCard.faceUp) {
                            for (let targetCol = 0; targetCol < 7; targetCol++) {
                                if (sourceCol !== targetCol) {
                                    const targetCard = tableau[targetCol].length > 0 ? 
                                        tableau[targetCol][tableau[targetCol].length - 1] : null;
                                    if (canPlaceOnTableau(sourceCard, targetCard)) {
                                        possibleMoves++;
                                    }
                                }
                            }
                        }
                    }
                }
                
                solvabilityScore += possibleMoves * 5;
                
                // 3. í‚¹ë“¤ì˜ ë°°ì¹˜ ìƒíƒœ ì²´í¬
                let kingsInGoodPosition = 0;
                for (let col = 0; col < 7; col++) {
                    if (tableau[col].length > 0) {
                        const bottomCard = tableau[col][0];
                        if (bottomCard.rank === 'king') {
                            kingsInGoodPosition++;
                            solvabilityScore += 10;
                        }
                    }
                }
                
                // 4. ë’¤ì§‘ì–´ì§„ ì¹´ë“œë“¤ì˜ ìƒíƒœ ì²´í¬
                let hiddenCardRatio = 0;
                let totalCards = 0;
                let hiddenCards = 0;
                
                for (let col = 0; col < 7; col++) {
                    totalCards += tableau[col].length;
                    hiddenCards += tableau[col].filter(card => !card.faceUp).length;
                }
                
                hiddenCardRatio = totalCards > 0 ? hiddenCards / totalCards : 0;
                solvabilityScore += (1 - hiddenCardRatio) * 20; // ì ì€ ìˆ¨ê²¨ì§„ ì¹´ë“œì¼ìˆ˜ë¡ ì¢‹ìŒ
                

                
                // í•´ê²° ë¶ˆê°€ëŠ¥í•  ê°€ëŠ¥ì„±ì´ ë†’ì€ ê²Œì„ë“¤ í•„í„°ë§
                if (solvabilityScore < 30) {
                    issues.push('ì „ì²´ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ë§¤ìš° ì–´ë ¤ìš´ ë°°ì¹˜');
                }
                if (accessibleAces === 0) {
                    issues.push('ì¦‰ì‹œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì—ì´ìŠ¤ê°€ ì—†ìŒ');
                }
                if (possibleMoves === 0) {
                    issues.push('ì´ˆê¸° ì´ë™ ê°€ëŠ¥í•œ ì¹´ë“œê°€ ì—†ìŒ');
                }
                if (hiddenCardRatio > 0.8) {
                    issues.push('ë„ˆë¬´ ë§ì€ ì¹´ë“œê°€ ë’¤ì§‘ì–´ì ¸ ìˆìŒ');
                }
                
                return {
                    score: solvabilityScore,
                    solvable: solvabilityScore >= 40 && possibleMoves > 0,
                    issues: issues
                };
            }

            // ê²Œì„ ì´ˆê¸°í™” (í•´ê²° ê°€ëŠ¥í•œ ê²Œì„ë§Œ ìƒì„±)
            function newGame() {
                let attempts = 0;
                const maxAttempts = 10; // ìµœëŒ€ 10ë²ˆ ì‹œë„
                
                let gameAnalysis;
                
                do {
                    attempts++;
                    createDeck();
                    shuffleDeck();
                    
                    // ì´ˆê¸°í™”
                    stock = [...deck];
                    waste = [];
                    foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
                    tableau = [[], [], [], [], [], [], []];
                    score = 0;
                    moves = 0;
                    startTime = Date.now();
                    gameWon = false;
                    drawCount = 0;
                    gameHistory = [];
                    isProcessingDoubleClick = false;

                    // íƒ€ë¸”ë¡œ ë°°ì¹˜
                    let tableauCount = 0;
                    for (let col = 0; col < 7; col++) {
                        for (let row = 0; row <= col; row++) {
                            if (stock.length === 0) break;
                            const card = stock.pop();
                            if (!card || !card.suit || !card.rank) continue;
                            if (row === col) {
                                card.faceUp = true;
                            }
                            tableau[col].push(card);
                            tableauCount++;
                        }
                    }
                    
                    // í•´ê²° ê°€ëŠ¥ì„± ì²´í¬
                    gameAnalysis = checkGameSolvability();
                    
                    // í•´ê²° ë¶ˆê°€ëŠ¥í•˜ë©´ ë‹¤ì‹œ ì‹œë„
                    
                } while (!gameAnalysis.solvable && attempts < maxAttempts);
                
                // ê²Œì„ ìƒì„± ì™„ë£Œ
                dealCardsWithAnimation();
                updateTimer();
            }

            // ì¼ë°˜ ê²Œì„ í”Œë ˆì´ìš© ì¹´ë“œ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ (ë¶€ë“œëŸ¬ìš´ ì†ë„)
            function animateCardMove(cardElement, targetElement, onComplete) {
                const startRect = cardElement.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                
                // ì‹œì‘ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                const deltaX = targetRect.left - startRect.left;
                const deltaY = targetRect.top - startRect.top;
                
                // ì¼ë°˜ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
                cardElement.classList.add('move-animation-normal');
                
                // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
                cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì½œë°± ì‹¤í–‰ (ë¶€ë“œëŸ¬ìš´ 400ms)
                setTimeout(() => {
                    cardElement.classList.remove('move-animation-normal');
                    cardElement.style.transform = '';
                    onComplete();
                }, 400);
            }

            // ìë™ ì™„ì„±ìš© ë¹ ë¥¸ ì—°ì† ì• ë‹ˆë©”ì´ì…˜ (ì¹´ë“œë“¤ì´ ì¤‘ë³µë˜ë©° ì´ë™)
            function autoCompleteAnimateCardMove(cardElement, targetElement, onComplete) {
                const startRect = cardElement.getBoundingClientRect();
                const targetRect = targetElement.getBoundingClientRect();
                
                // ì‹œì‘ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
                const deltaX = targetRect.left - startRect.left;
                const deltaY = targetRect.top - startRect.top;
                
                // ë¹ ë¥¸ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
                cardElement.classList.add('move-animation-fast');
                
                // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
                cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                
                // ë¹ ë¥¸ ì™„ë£Œ í›„ ì½œë°± ì‹¤í–‰ (150ms)
                setTimeout(() => {
                    cardElement.classList.remove('move-animation-fast');
                    cardElement.style.transform = '';
                    onComplete();
                }, 150);
            }

            // ì¹´ë“œ ë½‘ê¸° ì• ë‹ˆë©”ì´ì…˜
            function animateCardDraw(drawnCards) {
                if (!drawnCards || drawnCards.length === 0) return;
                
                // ì›¨ì´ìŠ¤íŠ¸ ì˜ì—­ì˜ ìƒˆë¡œ ì¶”ê°€ëœ ì¹´ë“œë“¤ ì°¾ê¸°
                const wasteEl = document.getElementById('waste');
                const newCards = wasteEl.querySelectorAll('.card');
                const startIndex = Math.max(0, newCards.length - drawnCards.length);
                
                // CSS ë³€ìˆ˜ì—ì„œ ê³ ì •ëœ offset ê°’ ì‚¬ìš©
                const offset = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--waste-card-offset'));
                
                // ìƒˆë¡œìš´ ì¹´ë“œë“¤ì„ ëª¨ë‘ ì™¼ìª½ ëì— ê²¹ì³ì„œ ìœ„ì¹˜ì‹œí‚¤ê¸°
                for (let i = startIndex; i < newCards.length; i++) {
                    const cardEl = newCards[i];
                    const cardOrder = i - startIndex;
                    
                    // ëª¨ë“  ì¹´ë“œë¥¼ ì™¼ìª½ ëì— ê²¹ì³ì„œ ìœ„ì¹˜
                    cardEl.style.position = 'absolute';
                    cardEl.style.left = '0px';
                    cardEl.style.top = '0px';
                    cardEl.style.zIndex = cardOrder.toString();
                    cardEl.style.transition = 'transform 0.4s ease-out';
                    cardEl.style.transform = 'translateX(0)';
                }
                
                // ë§¨ ìœ„ ì¹´ë“œë¶€í„° ì‹œì‘í•´ì„œ ì „ì²´ê°€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œí•˜ë©´ì„œ í¼ì³ì§€ê¸°
                setTimeout(() => {
                    // ë§¨ ìœ„ ì¹´ë“œ(ë§ˆì§€ë§‰ ì¹´ë“œ)ê°€ ë¨¼ì € ì›€ì§ì´ê¸° ì‹œì‘
                    const topCardIndex = newCards.length - 1;
                    const topCardOrder = topCardIndex - startIndex;
                    const topCard = newCards[topCardIndex];
                    
                    if (topCard) {
                        // ë§¨ ìœ„ ì¹´ë“œë¥¼ ìµœì¢… ìœ„ì¹˜ë¡œ ì´ë™
                        topCard.style.transform = `translateX(${topCardOrder * offset}px)`;
                    }
                    
                    // ë‚˜ë¨¸ì§€ ì¹´ë“œë“¤ì´ ìì—°ìŠ¤ëŸ½ê²Œ ë”°ë¼ê°€ë©´ì„œ í¼ì³ì§€ê¸°
                    for (let i = startIndex; i < newCards.length - 1; i++) {
                        const cardEl = newCards[i];
                        const cardOrder = i - startIndex;
                        
                        setTimeout(() => {
                            // ê° ì¹´ë“œë¥¼ ìµœì¢… ìœ„ì¹˜ë¡œ ìŠ¬ë¼ì´ë“œ
                            cardEl.style.transform = `translateX(${cardOrder * offset}px)`;
                        }, cardOrder * 80);
                    }
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤íƒ€ì¼ ì •ë¦¬
                    setTimeout(() => {
                        for (let i = startIndex; i < newCards.length; i++) {
                            const cardEl = newCards[i];
                            cardEl.style.position = '';
                            cardEl.style.transition = '';
                            cardEl.style.transform = '';
                            // leftì™€ zIndexëŠ” ê¸°ë³¸ ë Œë”ë§ì—ì„œ ì„¤ì •ë¨
                        }
                        // ìµœì¢… ë Œë”ë§ìœ¼ë¡œ ì •ë¦¬
                        renderGame();
                    }, 300 + (drawnCards.length - 1) * 60);
                }, 100);
            }

            // ê²Œì„ ì‹œì‘ì‹œ ì¹´ë“œ ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜
            function dealCardsWithAnimation() {
                // ë¨¼ì € í™”ë©´ì„ í´ë¦¬ì–´í•˜ê³  ê¸°ë³¸ ë Œë”ë§
                renderGame();
                
                // ì ì‹œ í›„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
                setTimeout(() => {
                    // ìŠ¤í†¡ ìœ„ì¹˜ ì¢Œí‘œ (ê¸°ì¤€ì )
                    const stockEl = document.getElementById('stock');
                    const stockRect = stockEl.getBoundingClientRect();
                    
                    // ëª¨ë“  íƒ€ë¸”ë¡œ ì¹´ë“œë“¤ì„ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ëª¨ìœ¼ê¸°
                    const allTableauCards = document.querySelectorAll('.column .card');
                    
                    // ì¹´ë“œë“¤ì„ ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (ë’·ë©´ë¶€í„° ë°°ì¹˜ë˜ë„ë¡)
                    const cardsToAnimate = [];
                    for (let col = 0; col < 7; col++) {
                        for (let row = 0; row <= col; row++) {
                            const card = document.querySelector(`.column[data-column="${col}"] .card:nth-child(${row + 1})`);
                            if (card) {
                                cardsToAnimate.push({ card, col, row, order: cardsToAnimate.length });
                            }
                        }
                    }
                    
                    // ëª¨ë“  ì¹´ë“œë¥¼ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì´ë™
                    cardsToAnimate.forEach((item, index) => {
                        const cardRect = item.card.getBoundingClientRect();
                        const deltaX = stockRect.left - cardRect.left;
                        const deltaY = stockRect.top - cardRect.top;
                        
                        // ì¹´ë“œë¥¼ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì´ë™ (ì™„ì „íˆ ë­‰ì³ìˆê²Œ)
                        item.card.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        item.card.style.transition = 'none';
                        item.card.style.zIndex = (1000 + index).toString(); // ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ z-index
                    });
                    
                    // ì¹´ë“œ ë’·ë©´ì„ ë§¨ ìœ„ë¡œ (ìŠ¤í†¡ ì¹´ë“œ)
                    const stockCard = stockEl.querySelector('.card');
                    if (stockCard) {
                        stockCard.style.zIndex = '2000'; // ê°€ì¥ ìœ„ì—
                    }
                    
                    // ìˆœì°¨ì ìœ¼ë¡œ ì¹´ë“œ ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë’·ë©´ë¶€í„° ì •ëˆë˜ê²Œ)
                    setTimeout(() => {
                        let delay = 0;
                        
                        // ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ ì¹´ë“œë“¤ì„ ê°ì ì›ë˜ ìœ„ì¹˜ë¡œ ìŠ¬ë¼ì´ë“œ
                        cardsToAnimate.forEach((item, index) => {
                            setTimeout(() => {
                                // íŠ¸ëœì§€ì…˜ ì„¤ì • (ë” ë¶€ë“œëŸ½ê³  ë¹ ë¥´ê²Œ)
                                item.card.style.transition = 'transform 0.4s ease-out';
                                
                                // ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¬ê¸°
                                item.card.style.transform = 'translate(0, 0)';
                                
                                // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤íƒ€ì¼ ì œê±°
                                setTimeout(() => {
                                    item.card.style.transform = '';
                                    item.card.style.transition = '';
                                    item.card.style.zIndex = '';
                                }, 400);
                            }, delay);
                            delay += 40; // ê° ì¹´ë“œë§ˆë‹¤ 40ms ê°„ê²© (ë” ë¹ ë¥´ê³  ë§¤ë„ëŸ½ê²Œ)
                        });
                        
                        // ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤í†¡ ì¹´ë“œ z-index ì›ë³µ
                        setTimeout(() => {
                            if (stockCard) {
                                stockCard.style.zIndex = '';
                            }
                        }, delay + 400);
                    }, 300); // ì¹´ë“œë“¤ì´ ë­‰ì¹œ í›„ 300ms ëŒ€ê¸°
                }, 100); // ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°
            }

            // ê²Œì„ ë Œë”ë§
            function renderGame() {
                // ìŠ¤í†¡ ë Œë”ë§
                const stockEl = document.getElementById('stock');
                stockEl.innerHTML = '';
                
                // ê¸°ì¡´ í´ë¦­ ì´ë²¤íŠ¸ ì œê±° (HTMLì˜ onclick ì†ì„±ì€ ìœ ì§€)
                stockEl.onclick = null;
                
                if (stock.length > 0) {
                    // ë’·ë©´ ì¹´ë“œ ìƒì„±
                    const backCard = document.createElement('div');
                    backCard.className = 'card face-down with-image';
                    backCard.innerHTML = '';
                    backCard.style.backgroundImage = `url('./cards/back.png')`;
                    backCard.style.position = 'absolute';
                    backCard.style.top = '0';
                    backCard.style.left = '0';
                    backCard.style.cursor = 'pointer';
                    // ì¹´ë“œì—ë§Œ í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²° (ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë°©ì§€)
                    backCard.onclick = function(e) {
                        e.stopPropagation();
                        drawCard();
                    };
                    
                    // ìŠ¤í†¡ ì¹´ë“œ ë”ë¸”í´ë¦­ ì´ë²¤íŠ¸ (ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™) - ì´ì „ ë²„ì „ê³¼ ì™„ì „íˆ ë™ì¼í•˜ê²Œ
                    backCard.addEventListener('dblclick', function(e) {
                        e.stopPropagation();
                        if (waste.length > 0) {
                            const card = waste[waste.length - 1];
                            if (canPlaceOnFoundation(card, card.suit)) {
                                const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                                // ì›¨ì´ìŠ¤íŠ¸ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ìš”ì†Œë¥¼ ì°¾ê¸°
                                const wasteEl = document.getElementById('waste');
                                const wasteCards = wasteEl.querySelectorAll('.card');
                                const lastWasteCard = wasteCards[wasteCards.length - 1];
                                
                                if (lastWasteCard) {
                                    animateCardMove(lastWasteCard, targetFoundation, () => {
                                        if (waste.length > 0 && waste[waste.length - 1] === card) {
                                            saveGameState();
                                            waste.pop();
                                            foundations[card.suit].push(card);
                                            moves++;
                                            score += 10;
                                            animateScoreIncrease(10);
                                            renderGame();
                                            checkWin();
                                            checkAutoComplete();
                                        }
                                    });
                                }
                            }
                        }
                    });
                    
                    // ìŠ¤í†¡ ì¹´ë“œ í„°ì¹˜ ì´ë²¤íŠ¸
                    backCard.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        drawCard();
                    });
                    stockEl.appendChild(backCard);
                } else {
                    // ìŠ¤í†¡ì´ ë¹„ì—ˆì„ ë•Œë§Œ ìŠ¬ë¡¯ì— í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²°
                    stockEl.onclick = function(e) {
                        e.stopPropagation();
                        drawCard();
                    };
                    
                    // ë¹ˆ ìŠ¤í†¡ ìŠ¬ë¡¯ í„°ì¹˜ ì´ë²¤íŠ¸
                    stockEl.addEventListener('touchstart', function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        drawCard();
                    });
                    stockEl.style.cursor = waste.length > 0 ? 'pointer' : 'default';
                }

                // ì›¨ì´ìŠ¤íŠ¸ ë Œë”ë§ (ìµœëŒ€ 3ì¥ ê²¹ì³ì„œ í‘œì‹œ)
                const wasteEl = document.getElementById('waste');
                wasteEl.innerHTML = '';
                if (waste.length > 0) {
                    waste = waste.filter(card => card && card.suit && card.rank);
                    
                    if (waste.length > 0) {
                        const visibleCount = Math.min(3, waste.length);
                        const startIndex = waste.length - visibleCount;
                        let renderedCount = 0;
                        
                        for (let i = 0; i < visibleCount; i++) {
                            const cardIndex = startIndex + i;
                            const card = waste[cardIndex];
                            const cardEl = createCardElement(card);
                            
                            if (!cardEl) continue;
                            
                            cardEl.style.position = 'absolute';
                            cardEl.style.top = '0';
                            
                            // CSS ë³€ìˆ˜ì—ì„œ ê³ ì •ëœ offset ê°’ ì‚¬ìš©
                            const offset = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--waste-card-offset'));
                            
                            cardEl.style.left = `${renderedCount * offset}px`;
                            cardEl.style.zIndex = renderedCount + 1;
                            
                            // ë§¨ ìœ„ ì¹´ë“œ(ë§ˆì§€ë§‰ ì¹´ë“œ)ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê³  ì´ë²¤íŠ¸ ì¶”ê°€
                            if (i === visibleCount - 1) {
                                cardEl.classList.add('waste-card');
                                cardEl.dataset.wasteCard = 'true';
                                cardEl.dataset.wasteIndex = cardIndex;
                                cardEl.style.zIndex = 100;
                                
                                // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ì „ìš© ë“œë˜ê·¸ ì´ë²¤íŠ¸
                                cardEl.addEventListener('dragstart', (e) => {
                                    document.querySelectorAll('.column, .foundation').forEach(el => {
                                        el.classList.remove('drag-over');
                                    });
                                    
                                    draggedCard = { index: waste.length - 1 };
                                    draggedFrom = 'waste';
                                    cardEl.classList.add('dragging');
                                    e.dataTransfer.effectAllowed = 'move';
                                });
                                
                                // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ í„°ì¹˜ ì´ë²¤íŠ¸
                                cardEl.addEventListener('touchstart', (e) => {
                                    e.preventDefault();
                                    const touch = e.touches[0];
                                    
                                    touchStartTime = Date.now();
                                    touchStartX = touch.clientX;
                                    touchStartY = touch.clientY;
                                    
                                    draggedCard = { index: waste.length - 1 };
                                    draggedFrom = 'waste';
                                    cardEl.classList.add('dragging');
                                    
                                    // ë“œë˜ê·¸ í”„ë¦¬ë·° ìƒì„±
                                    createDragPreview(cardEl, waste[waste.length - 1]);
                                });
                                
                                cardEl.addEventListener('touchmove', (e) => {
                                    e.preventDefault();
                                    
                                    if (!draggedCard || draggedFrom !== 'waste' || !dragPreview) return;
                                    
                                    const touch = e.touches[0];
                                    const touchDistance = Math.sqrt(
                                        Math.pow(touch.clientX - touchStartX, 2) + 
                                        Math.pow(touch.clientY - touchStartY, 2)
                                    );
                                    
                                    if (touchDistance > 10) {
                                        isTouchDragging = true;
                                        
                                        // ë“œë˜ê·¸ í”„ë¦¬ë·° ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                                        dragPreview.style.left = (touch.clientX - dragPreview.offsetWidth / 2) + 'px';
                                        dragPreview.style.top = (touch.clientY - dragPreview.offsetHeight / 2) + 'px';
                                        
                                        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                                        const dropTarget = elementBelow ? elementBelow.closest('.column, .foundation') : null;
                                        
                                        document.querySelectorAll('.column, .foundation').forEach(el => {
                                            el.classList.remove('drag-over');
                                        });
                                        
                                        if (dropTarget) {
                                            if (dropTarget.classList.contains('column')) {
                                                const targetCol = parseInt(dropTarget.dataset.column);
                                                const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;
                                                const card = waste[waste.length - 1];
                                                
                                                if (card && canPlaceOnTableau(card, targetCard)) {
                                                    dropTarget.classList.add('drag-over');
                                                }
                                            } else if (dropTarget.classList.contains('foundation')) {
                                                const targetSuit = dropTarget.dataset.suit;
                                                const card = waste[waste.length - 1];
                                                
                                                if (card && canPlaceOnFoundation(card, targetSuit)) {
                                                    dropTarget.classList.add('drag-over');
                                                }
                                            }
                                        }
                                    }
                                });
                                
                                // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™
                                cardEl.addEventListener('dblclick', () => {
                                    if (isProcessingDoubleClick || waste.length === 0) return;
                                    
                                    const card = waste[waste.length - 1];
                                    if (!card || !card.suit || !card.rank) return;
                                    
                                    if (canPlaceOnFoundation(card, card.suit)) {
                                        isProcessingDoubleClick = true;
                                        const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                                        
                                        animateCardMove(cardEl, targetFoundation, () => {
                                            if (waste.length > 0 && waste[waste.length - 1] === card) {
                                                saveGameState();
                                                waste.pop();
                                                foundations[card.suit].push(card);
                                                moves++;
                                                score += 10;
                                                animateScoreIncrease(10);
                                                renderGame();
                                                checkWin();
                                                checkAutoComplete();
                                            }
                                            isProcessingDoubleClick = false;
                                        });
                                    }
                                });
                                
                                // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ í„°ì¹˜ ì´ë²¤íŠ¸ (ë“œë˜ê·¸ + ë”ë¸”íƒ­)
                                let lastWasteTapTime = 0;
                                cardEl.addEventListener('touchend', (e) => {
                                    e.preventDefault();
                                    
                                    const touch = e.changedTouches[0];
                                    const touchEndTime = Date.now();
                                    const touchDuration = touchEndTime - touchStartTime;
                                    const touchDistance = Math.sqrt(
                                        Math.pow(touch.clientX - touchStartX, 2) + 
                                        Math.pow(touch.clientY - touchStartY, 2)
                                    );
                                    
                                    // ë“œë˜ê·¸ í”„ë¦¬ë·° ì œê±°
                                    if (dragPreview) {
                                        document.body.removeChild(dragPreview);
                                        dragPreview = null;
                                    }
                                    
                                    if (isTouchDragging && touchDistance > 10) {
                                        // ë“œë˜ê·¸ ì²˜ë¦¬
                                        const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                                        const dropTarget = elementBelow ? elementBelow.closest('.column, .foundation') : null;
                                        
                                        if (dropTarget) {
                                            if (dropTarget.classList.contains('column')) {
                                                const targetCol = parseInt(dropTarget.dataset.column);
                                                handleTableauDrop(targetCol);
                                            } else if (dropTarget.classList.contains('foundation')) {
                                                const targetSuit = dropTarget.dataset.suit;
                                                handleFoundationDrop(targetSuit);
                                            }
                                        }
                                    } else if (touchDuration < 300 && touchDistance < 10) {
                                        // ì§§ì€ í„°ì¹˜ - ë”ë¸”íƒ­ í™•ì¸
                                        const currentTime = new Date().getTime();
                                        const tapLength = currentTime - lastWasteTapTime;
                                        
                                        if (tapLength < 500 && tapLength > 0) {
                                            if (isProcessingDoubleClick || waste.length === 0) return;
                                            
                                            const card = waste[waste.length - 1];
                                            if (!card || !card.suit || !card.rank) return;
                                            
                                            if (canPlaceOnFoundation(card, card.suit)) {
                                                isProcessingDoubleClick = true;
                                                const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                                                
                                                animateCardMove(cardEl, targetFoundation, () => {
                                                    if (waste.length > 0 && waste[waste.length - 1] === card) {
                                                        saveGameState();
                                                        waste.pop();
                                                        foundations[card.suit].push(card);
                                                        moves++;
                                                        score += 10;
                                                        animateScoreIncrease(10);
                                                        renderGame();
                                                        checkWin();
                                                        checkAutoComplete();
                                                    }
                                                    isProcessingDoubleClick = false;
                                                });
                                            }
                                        }
                                        lastWasteTapTime = currentTime;
                                    }
                                    
                                    cardEl.classList.remove('dragging');
                                    draggedCard = null;
                                    draggedFrom = null;
                                    isTouchDragging = false;
                                    
                                    document.querySelectorAll('.column, .foundation').forEach(el => {
                                        el.classList.remove('drag-over');
                                    });
                                });
                            } else {
                                cardEl.draggable = false;
                                cardEl.style.cursor = 'default';
                            }
                            
                            wasteEl.appendChild(cardEl);
                            renderedCount++;
                        }
                    }
                }

                // íŒŒìš´ë°ì´ì…˜ ë Œë”ë§
                for (let suit in foundations) {
                    const foundationEl = document.querySelector(`.foundation[data-suit="${suit}"]`);
                    foundationEl.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">${getSuitSymbol(suit)}</div>`;
                    
                    if (foundations[suit].length > 0) {
                        const topCard = foundations[suit][foundations[suit].length - 1];
                        const cardEl = createCardElement(topCard);
                        foundationEl.appendChild(cardEl);
                    }
                }

                // íƒ€ë¸”ë¡œ ë Œë”ë§
                for (let col = 0; col < 7; col++) {
                    const columnEl = document.querySelector(`.column[data-column="${col}"]`);
                    columnEl.innerHTML = '';
                    
                    // ë¹ˆ ì»¬ëŸ¼ í‘œì‹œ
                    if (tableau[col].length === 0) {
                        columnEl.classList.add('empty');
                    } else {
                        columnEl.classList.remove('empty');
                    }
                    
                    tableau[col].forEach((card, index) => {
                        const cardEl = createCardElement(card);
                        
                        // ë°˜ì‘í˜• ì¹´ë“œ ê°„ê²© - CSS ë¸Œë ˆì´í¬í¬ì¸íŠ¸ì™€ ì •í™•íˆ ì¼ì¹˜
                        let cardOffset;
                        if (window.innerWidth > 1200) {
                            cardOffset = 25; // ê¸°ë³¸ (180px ì¹´ë“œ)
                        } else if (window.innerWidth > 900) {
                            cardOffset = 25; // 152px ì¹´ë“œ
                        } else if (window.innerWidth > 768) {
                            cardOffset = 21; // 124px ì¹´ë“œ
                        } else if (window.innerWidth > 600) {
                            cardOffset = 16; // 96px ì¹´ë“œ
                        } else {
                            cardOffset = 14; // 82px ì¹´ë“œ
                        }
                        
                        cardEl.style.top = `${index * cardOffset}px`;
                        cardEl.style.zIndex = index;
                        cardEl.dataset.column = col;
                        cardEl.dataset.index = index;
                        
                        // íƒ€ë¸”ë¡œ ì¹´ë“œ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™ (ë§¨ ìœ„ ì¹´ë“œë§Œ, ì•ˆì „ì¥ì¹˜ ì¶”ê°€)
                        if (card.faceUp && index === tableau[col].length - 1) {
                            // ë”ë¸”í´ë¦­ ì´ë²¤íŠ¸ (PCìš©)
                            cardEl.addEventListener('dblclick', () => {
                                handleTableauCardDoubleClick(card, col, index, cardEl);
                            });
                            
                            // ë”ë¸”íƒ­ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼ìš©)
                            let lastTapTime = 0;
                            cardEl.addEventListener('touchend', (e) => {
                                const currentTime = new Date().getTime();
                                const tapLength = currentTime - lastTapTime;
                                
                                if (tapLength < 500 && tapLength > 0) {
                                    e.preventDefault();
                                    handleTableauCardDoubleClick(card, col, index, cardEl);
                                }
                                lastTapTime = currentTime;
                            });
                        }
                        
                        // íƒ€ë¸”ë¡œ ì¹´ë“œ í„°ì¹˜ ì´ë²¤íŠ¸ (faceUp ì¹´ë“œë§Œ)
                        if (card.faceUp) {
                            cardEl.addEventListener('touchstart', handleTouchStart);
                            cardEl.addEventListener('touchmove', handleTouchMove);
                            cardEl.addEventListener('touchend', handleTouchEnd);
                        }
                        
                        columnEl.appendChild(cardEl);
                    });
                }

                // ë“œë¡­ ì¡´ ì¶”ê°€
                addDropListeners();
                updateScore();
            }

            // ë“œë¡­ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
            function addDropListeners() {
                // íƒ€ë¸”ë¡œ ë“œë¡­
                document.querySelectorAll('.column').forEach(col => {
                    col.addEventListener('dragover', handleDragOver);
                    col.addEventListener('drop', handleDrop);
                    col.addEventListener('dragleave', handleDragLeave);
                });

                // íŒŒìš´ë°ì´ì…˜ ë“œë¡­
                document.querySelectorAll('.foundation').forEach(foundation => {
                    foundation.addEventListener('dragover', handleDragOver);
                    foundation.addEventListener('drop', handleDrop);
                    foundation.addEventListener('dragleave', handleDragLeave);
                });
            }


            
            // ë“œë˜ê·¸ ë¦¬ë¸Œ
            function handleDragLeave(e) {
                // ì»¨í…Œì´ë„ˆë¥¼ ì™„ì „íˆ ë²—ì–´ë‚¬ì„ ë•Œë§Œ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    e.currentTarget.classList.remove('drag-over');
                }
            }

            // ë“œë˜ê·¸ ì‹œì‘
            function handleDragStart(e) {
                const cardEl = e.target;
                const col = parseInt(cardEl.dataset.column);
                const index = parseInt(cardEl.dataset.index);
                
                // ê¸°ì¡´ í•˜ì´ë¼ì´íŠ¸ ì œê±°
                document.querySelectorAll('.column, .foundation').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                // íƒ€ë¸”ë¡œ ì¹´ë“œ ë“œë˜ê·¸ë§Œ ì²˜ë¦¬ (ì›¨ì´ìŠ¤íŠ¸ëŠ” ì „ìš© ë¦¬ìŠ¤ë„ˆ ì‚¬ìš©)
                if (col !== undefined && index !== undefined) {
                    const card = tableau[col][index];
                    if (card && card.faceUp) {
                        draggedCard = { col, index };
                        draggedFrom = 'tableau';
                        cardEl.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    }
                }
            }

            // ë“œë˜ê·¸ ì˜¤ë²„
            function handleDragOver(e) {
                e.preventDefault();
                
                if (!draggedCard) return;
                
                const dropTarget = e.target.closest('.column, .foundation');
                if (!dropTarget) return;
                
                // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
                document.querySelectorAll('.column, .foundation').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                // ìœ íš¨í•œ ë“œë¡­ ìœ„ì¹˜ì¸ì§€ í™•ì¸í•˜ê³  í•˜ì´ë¼ì´íŠ¸
                if (dropTarget.classList.contains('column')) {
                    const targetCol = parseInt(dropTarget.dataset.column);
                    const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;
                    
                    let card = null;
                    if (draggedFrom === 'tableau') {
                        const { col: sourceCol, index } = draggedCard;
                        if (sourceCol !== targetCol) {
                            card = tableau[sourceCol][index];
                        }
                    } else if (draggedFrom === 'waste') {
                        card = waste[draggedCard.index];
                    }
                    
                    if (card && canPlaceOnTableau(card, targetCard)) {
                        dropTarget.classList.add('drag-over');
                    }
                } else if (dropTarget.classList.contains('foundation')) {
                    const targetSuit = dropTarget.dataset.suit;
                    
                    let card = null;
                    if (draggedFrom === 'tableau') {
                        const { col, index } = draggedCard;
                        if (index === tableau[col].length - 1) {
                            card = tableau[col][index];
                        }
                    } else if (draggedFrom === 'waste') {
                        card = waste[draggedCard.index];
                    }
                    
                    if (card && canPlaceOnFoundation(card, targetSuit)) {
                        dropTarget.classList.add('drag-over');
                    }
                }
            }

            // ë“œë¡­ ì²˜ë¦¬
            function handleDrop(e) {
                e.preventDefault();
                
                if (!draggedCard) return;

                const dropTarget = e.target.closest('.column, .foundation');
                if (!dropTarget) return;

                if (dropTarget.classList.contains('column')) {
                    const targetCol = parseInt(dropTarget.dataset.column);
                    handleTableauDrop(targetCol);
                } else if (dropTarget.classList.contains('foundation')) {
                    const targetSuit = dropTarget.dataset.suit;
                    handleFoundationDrop(targetSuit);
                }

                // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
                document.querySelectorAll('.card.dragging').forEach(card => {
                    card.classList.remove('dragging');
                });
                
                // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
                document.querySelectorAll('.column, .foundation').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                draggedCard = null;
                draggedFrom = null;
            }

            // íƒ€ë¸”ë¡œ ë“œë¡­ ì²˜ë¦¬
            function handleTableauDrop(targetCol) {
                if (draggedFrom === 'tableau') {
                    const { col: sourceCol, index } = draggedCard;
                    
                    // ê°™ì€ ì»¬ëŸ¼ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²½ìš° ë¬´ì‹œ
                    if (sourceCol === targetCol) return;
                    
                    const cardsToMove = tableau[sourceCol].slice(index);
                    const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;

                    if (canPlaceOnTableau(cardsToMove[0], targetCard)) {
                        saveGameState();
                        
                        // ì¹´ë“œ ì´ë™
                        tableau[sourceCol].splice(index);
                        tableau[targetCol].push(...cardsToMove);
                        
                        // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                        if (tableau[sourceCol].length > 0) {
                            const lastCard = tableau[sourceCol][tableau[sourceCol].length - 1];
                            if (!lastCard.faceUp) {
                                lastCard.faceUp = true;
                                score += 5;
                            }
                        }
                        
                        moves++;
                        score += 5;
                        animateScoreIncrease(5);
                        renderGame();
                        checkWin();
                    }
                } else if (draggedFrom === 'waste') {
                    const card = waste[draggedCard.index];
                    const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;

                    if (canPlaceOnTableau(card, targetCard)) {
                        saveGameState();
                        waste.pop();
                        tableau[targetCol].push(card);
                        moves++;
                        score += 5;
                        animateScoreIncrease(5);
                        renderGame();
                        checkWin();
                    }
                }
            }

            // íŒŒìš´ë°ì´ì…˜ ë“œë¡­ ì²˜ë¦¬
            function handleFoundationDrop(targetSuit) {
                let card = null;
                
                if (draggedFrom === 'tableau') {
                    const { col, index } = draggedCard;
                    if (index !== tableau[col].length - 1) return; // ë§¨ ìœ„ ì¹´ë“œë§Œ ê°€ëŠ¥
                    card = tableau[col][index];
                } else if (draggedFrom === 'waste') {
                    card = waste[draggedCard.index];
                }

                if (card && canPlaceOnFoundation(card, targetSuit)) {
                    saveGameState();
                    
                    // ì¹´ë“œ ì´ë™
                    if (draggedFrom === 'tableau') {
                        const { col, index } = draggedCard;
                        tableau[col].splice(index, 1);
                        
                        // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                        if (tableau[col].length > 0) {
                            const lastCard = tableau[col][tableau[col].length - 1];
                            if (!lastCard.faceUp) {
                                lastCard.faceUp = true;
                                score += 5;
                            }
                        }
                    } else if (draggedFrom === 'waste') {
                        waste.pop();
                    }
                    
                    foundations[targetSuit].push(card);
                    moves++;
                    score += 10;
                    animateScoreIncrease(10);
                    renderGame();
                    checkWin();
                    checkAutoComplete();
                }
            }

            // íƒ€ë¸”ë¡œ ë°°ì¹˜ ê°€ëŠ¥ í™•ì¸
            function canPlaceOnTableau(card, targetCard) {
                if (!targetCard) {
                    // ë¹ˆ ì¹¸ì—ëŠ” í‚¹ë§Œ ë†“ì„ ìˆ˜ ìˆìŒ
                    return card.rank === 'king';
                }
                // ê¸°ì¡´ ì¹´ë“œ ìœ„ì—ëŠ” ìƒ‰ì´ ë‹¤ë¥´ê³  ê°’ì´ 1 ì‘ì€ ì¹´ë“œë§Œ ê°€ëŠ¥
                return card.color !== targetCard.color && card.value === targetCard.value - 1;
            }

            // íŒŒìš´ë°ì´ì…˜ ë°°ì¹˜ ê°€ëŠ¥ í™•ì¸
            function canPlaceOnFoundation(card, targetSuit) {
                if (card.suit !== targetSuit) return false;
                const foundation = foundations[targetSuit];
                if (foundation.length === 0) return card.value === 1; // ì—ì´ìŠ¤
                return card.value === foundation[foundation.length - 1].value + 1;
            }

            // ì¹´ë“œ í´ë¦­ ì²˜ë¦¬
            function handleCardClick(e) {
                const cardEl = e.target;
                const col = parseInt(cardEl.dataset.column);
                const index = parseInt(cardEl.dataset.index);

                // ë’¤ì§‘íŒ ì¹´ë“œ í´ë¦­ì‹œ ì•ë©´ìœ¼ë¡œ (ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œëŠ” ì œì™¸)
                if (!isNaN(col) && !isNaN(index) && col !== undefined && index !== undefined && 
                    tableau[col] && tableau[col][index] && 
                    !tableau[col][index].faceUp && index === tableau[col].length - 1) {
                    saveGameState();
                    
                    // ì¹´ë“œ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜
                    cardEl.classList.add('flipping');
                    setTimeout(() => {
                        tableau[col][index].faceUp = true;
                        score += 5;
                        moves++;
                        animateScoreIncrease(5);
                        cardEl.classList.remove('flipping');
                        cardEl.classList.add('flipped');
                        renderGame();
                        setTimeout(() => {
                            cardEl.classList.remove('flipped');
                        }, 300);
                    }, 150);
                }
            }
            

            
            // ìë™ ì™„ì„± ì²´í¬ (ëª¨ë“  ì¹´ë“œê°€ ì˜¤í”ˆë˜ì—ˆì„ ë•Œ)
            function checkAutoComplete() {
                if (stock.length > 0) return;
                
                let allOpen = true;
                let hasTableauCards = false;
                
                for (let col = 0; col < tableau.length; col++) {
                    for (let card of tableau[col]) {
                        hasTableauCards = true;
                        if (!card.faceUp) {
                            allOpen = false;
                            break;
                        }
                    }
                    if (!allOpen) break;
                }
                
                if (allOpen && (hasTableauCards || waste.length > 0)) {
                    autoCompleteGame();
                }
            }
            
            // ìë™ ì™„ì„± ì‹¤í–‰ (ì´ˆê³ ì† ì• ë‹ˆë©”ì´ì…˜)
            function autoCompleteGame() {
                let autoMoveCount = 0;
                const maxAutoMoves = 500;
                
                const ultraFastAutoMove = () => {
                    autoMoveCount++;
                    if (autoMoveCount > maxAutoMoves) {
                        checkWin();
                        return;
                    }
                    
                    const totalFoundationCards = Object.values(foundations).reduce((sum, pile) => sum + pile.length, 0);
                    if (totalFoundationCards === 52) {
                        checkWin();
                        return;
                    }
                    
                    // ì›¨ì´ìŠ¤íŠ¸ì—ì„œ íŒŒìš´ë°ì´ì…˜ìœ¼ë¡œ ì´ë™ ì‹œë„
                    if (waste.length > 0) {
                        const wasteCard = waste[waste.length - 1];
                        if (canPlaceOnFoundation(wasteCard, wasteCard.suit)) {
                            // í˜„ì¬ ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ìš”ì†Œ ì°¾ê¸°
                            const wasteCardEl = document.querySelector('#waste .card:last-child');
                            const targetFoundation = document.querySelector(`.foundation[data-suit="${wasteCard.suit}"]`);
                            
                            if (wasteCardEl && targetFoundation) {
                                waste.pop();
                                foundations[wasteCard.suit].push(wasteCard);
                                score += 10;
                                moves++;
                                
                                                                  autoCompleteAnimateCardMove(wasteCardEl, targetFoundation, () => {
                                    renderGame();
                                });
                                // ì¤‘ë³µ íƒ€ì´ë°ìœ¼ë¡œ ë‹¤ìŒ ì¹´ë“œ ì´ë™ (ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚˜ê¸° ì „ì— ì‹œì‘)
                                setTimeout(ultraFastAutoMove, 80);
                                return;
                            }
                        }
                    }
                    
                    // íƒ€ë¸”ë¡œì—ì„œ íŒŒìš´ë°ì´ì…˜ìœ¼ë¡œ ì´ë™ ì‹œë„
                    for (let col = 0; col < tableau.length; col++) {
                        if (tableau[col].length > 0) {
                            const topCard = tableau[col][tableau[col].length - 1];
                            if (topCard.faceUp && canPlaceOnFoundation(topCard, topCard.suit)) {
                                // í˜„ì¬ íƒ€ë¸”ë¡œ ì¹´ë“œ ìš”ì†Œ ì°¾ê¸°
                                const cardEl = document.querySelector(`.column[data-column="${col}"] .card:last-child`);
                                const targetFoundation = document.querySelector(`.foundation[data-suit="${topCard.suit}"]`);
                                
                                if (cardEl && targetFoundation) {
                                    tableau[col].pop();
                                    
                                    if (tableau[col].length > 0) {
                                        const lastCard = tableau[col][tableau[col].length - 1];
                                        if (!lastCard.faceUp) {
                                            lastCard.faceUp = true;
                                            score += 5;
                                        }
                                    }
                                    
                                    foundations[topCard.suit].push(topCard);
                                    score += 10;
                                    moves++;
                                    
                                    autoCompleteAnimateCardMove(cardEl, targetFoundation, () => {
                                        renderGame();
                                    });
                                    // ì¤‘ë³µ íƒ€ì´ë°ìœ¼ë¡œ ë‹¤ìŒ ì¹´ë“œ ì´ë™ (ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚˜ê¸° ì „ì— ì‹œì‘)
                                    setTimeout(ultraFastAutoMove, 80);
                                    return;
                                }
                            }
                        }
                    }
                    
                    checkWin();
                };

            // ë Œë”ë§ ì™„ë£Œ í›„ ìë™ ì™„ì„± ì‹œì‘
            renderGame();
            setTimeout(ultraFastAutoMove, 5);
            }

            // ìŠ¤í†¡ì—ì„œ ì¹´ë“œ ë½‘ê¸° (3ì¥ì”©)
            function drawCard() {
                saveGameState();
                
                if (stock.length > 0) {
                    drawCount++;
                    const cardsToDraw = Math.min(3, stock.length);
                    const drawnCards = [];
                    
                    for (let i = 0; i < cardsToDraw; i++) {
                        if (stock.length === 0) break;
                        const card = stock.pop();
                        
                        if (!card || !card.suit || !card.rank) {
                            i--;
                            continue;
                        }
                        
                        card.faceUp = true;
                        drawnCards.push(card);
                    }
                    
                    waste.push(...drawnCards);
                    renderGame();
                    animateCardDraw(drawnCards);
                    
                } else if (waste.length > 0) {
                    const validWasteCards = waste.filter(c => c && c.suit && c.rank);
                    
                    validWasteCards.forEach(card => {
                        card.faceUp = false;
                    });
                    
                    stock = [...validWasteCards].reverse();
                    waste = [];
                    renderGame();
                }
            }



            // ìŠ¹ë¦¬ í™•ì¸
            function checkWin() {
                const totalFoundationCards = Object.values(foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalFoundationCards === 52) {
                    gameWon = true;
                    score += 100;
                    playWinAnimation();
                    setTimeout(() => showWinModal(), 2000);
                }
            }
            
            // ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜
            function playWinAnimation() {
                const foundationCards = [];
                
                Object.keys(foundations).forEach(suit => {
                    const foundationEl = document.querySelector(`.foundation[data-suit="${suit}"]`);
                    const cards = foundationEl.querySelectorAll('.card');
                    cards.forEach(card => foundationCards.push(card));
                });
                
                foundationCards.forEach((card, index) => {
                    setTimeout(() => {
                        card.classList.add('winning');
                    }, index * 50);
                });
                
                animateScoreIncrease(100);
            }

            // ìŠ¹ë¦¬ ëª¨ë‹¬ í‘œì‹œ
            function showWinModal() {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalTime').textContent = document.getElementById('time').textContent;
                document.getElementById('finalMoves').textContent = moves;
                document.getElementById('winModal').style.display = 'flex';
            }

            // ìŠ¹ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
            function closeWinModal() {
                document.getElementById('winModal').style.display = 'none';
            }

            // ì ìˆ˜ ì—…ë°ì´íŠ¸
            function updateScore() {
                document.getElementById('score').textContent = score;
                document.getElementById('moves').textContent = moves;
            }

            // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
            function updateTimer() {
                if (gameWon) return;
                
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                document.getElementById('time').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                setTimeout(updateTimer, 1000);
            }

            // ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
            let resizeTimeout;
            let currentBreakpoint = getCurrentBreakpoint();
            
            function getCurrentBreakpoint() {
                if (window.innerWidth > 1200) return 'large';
                if (window.innerWidth > 900) return 'medium';
                if (window.innerWidth > 768) return 'small';
                if (window.innerWidth > 600) return 'xsmall';
                return 'xxsmall';
            }
            
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    const newBreakpoint = getCurrentBreakpoint();
                    if (newBreakpoint !== currentBreakpoint) {
                        currentBreakpoint = newBreakpoint;
                        renderGame();
                    }
                }, 100);
            });

            // Touch event variables
            let touchStartTime = 0;
            let touchStartX = 0;
            let touchStartY = 0;
            let isTouchDragging = false;
            let dragPreview = null; // ë“œë˜ê·¸ í”„ë¦¬ë·° ìš”ì†Œ

            // í„°ì¹˜ ì‹œì‘
            function handleTouchStart(e) {
                e.preventDefault();
                const cardEl = e.target;
                const touch = e.touches[0];
                
                touchStartTime = Date.now();
                touchStartX = touch.clientX;
                touchStartY = touch.clientY;
                
                const col = parseInt(cardEl.dataset.column);
                const index = parseInt(cardEl.dataset.index);
                
                if (col !== undefined && index !== undefined) {
                    const card = tableau[col][index];
                    if (card && card.faceUp) {
                        draggedCard = { col, index };
                        draggedFrom = 'tableau';
                        cardEl.classList.add('dragging');
                        
                        // ë“œë˜ê·¸ í”„ë¦¬ë·° ìƒì„±
                        createDragPreview(cardEl, card);
                    }
                }
            }

            // ë“œë˜ê·¸ í”„ë¦¬ë·° ìƒì„±
            function createDragPreview(originalCard, cardData) {
                // ê¸°ì¡´ í”„ë¦¬ë·° ì œê±°
                if (dragPreview) {
                    document.body.removeChild(dragPreview);
                }
                
                // ìƒˆë¡œìš´ í”„ë¦¬ë·° ìƒì„±
                dragPreview = originalCard.cloneNode(true);
                dragPreview.style.position = 'fixed';
                dragPreview.style.pointerEvents = 'none';
                dragPreview.style.zIndex = '10000';
                dragPreview.style.opacity = '0.8';
                dragPreview.style.transform = 'rotate(5deg) scale(1.05)';
                dragPreview.style.transition = 'none';
                dragPreview.classList.add('drag-preview');
                
                // ì›ë³¸ ì¹´ë“œì˜ ìœ„ì¹˜ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì´ˆê¸° ìœ„ì¹˜ ì„¤ì •
                const rect = originalCard.getBoundingClientRect();
                dragPreview.style.left = rect.left + 'px';
                dragPreview.style.top = rect.top + 'px';
                
                document.body.appendChild(dragPreview);
            }

            // í„°ì¹˜ ì´ë™
            function handleTouchMove(e) {
                e.preventDefault();
                
                if (!draggedCard || !dragPreview) return;
                
                const touch = e.touches[0];
                const touchDistance = Math.sqrt(
                    Math.pow(touch.clientX - touchStartX, 2) + 
                    Math.pow(touch.clientY - touchStartY, 2)
                );
                
                // ìµœì†Œ ë“œë˜ê·¸ ê±°ë¦¬ í™•ì¸
                if (touchDistance > 10) {
                    isTouchDragging = true;
                    
                    // ë“œë˜ê·¸ í”„ë¦¬ë·° ìœ„ì¹˜ ì—…ë°ì´íŠ¸
                    dragPreview.style.left = (touch.clientX - dragPreview.offsetWidth / 2) + 'px';
                    dragPreview.style.top = (touch.clientY - dragPreview.offsetHeight / 2) + 'px';
                    
                    // í„°ì¹˜ ìœ„ì¹˜ì˜ ìš”ì†Œ ì°¾ê¸°
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    const dropTarget = elementBelow ? elementBelow.closest('.column, .foundation') : null;
                    
                    // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
                    document.querySelectorAll('.column, .foundation').forEach(el => {
                        el.classList.remove('drag-over');
                    });
                    
                    // ìœ íš¨í•œ ë“œë¡­ ìœ„ì¹˜ì¸ì§€ í™•ì¸í•˜ê³  í•˜ì´ë¼ì´íŠ¸
                    if (dropTarget) {
                        if (dropTarget.classList.contains('column')) {
                            const targetCol = parseInt(dropTarget.dataset.column);
                            const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;
                            
                            const { col: sourceCol, index } = draggedCard;
                            if (sourceCol !== targetCol) {
                                const card = tableau[sourceCol][index];
                                if (card && canPlaceOnTableau(card, targetCard)) {
                                    dropTarget.classList.add('drag-over');
                                }
                            }
                        } else if (dropTarget.classList.contains('foundation')) {
                            const targetSuit = dropTarget.dataset.suit;
                            const { col, index } = draggedCard;
                            
                            if (index === tableau[col].length - 1) {
                                const card = tableau[col][index];
                                if (card && canPlaceOnFoundation(card, targetSuit)) {
                                    dropTarget.classList.add('drag-over');
                                }
                            }
                        }
                    }
                }
            }

            // í„°ì¹˜ ì¢…ë£Œ
            function handleTouchEnd(e) {
                e.preventDefault();
                
                if (!draggedCard) return;
                
                const touch = e.changedTouches[0];
                const touchEndTime = Date.now();
                const touchDuration = touchEndTime - touchStartTime;
                const touchDistance = Math.sqrt(
                    Math.pow(touch.clientX - touchStartX, 2) + 
                    Math.pow(touch.clientY - touchStartY, 2)
                );
                
                // ë“œë˜ê·¸ í”„ë¦¬ë·° ì œê±°
                if (dragPreview) {
                    document.body.removeChild(dragPreview);
                    dragPreview = null;
                }
                
                // ë“œë˜ê·¸ ì¤‘ì´ì—ˆë‹¤ë©´ ë“œë¡­ ì²˜ë¦¬
                if (isTouchDragging && touchDistance > 10) {
                    const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                    const dropTarget = elementBelow ? elementBelow.closest('.column, .foundation') : null;
                    
                    if (dropTarget) {
                        if (dropTarget.classList.contains('column')) {
                            const targetCol = parseInt(dropTarget.dataset.column);
                            handleTableauDrop(targetCol);
                        } else if (dropTarget.classList.contains('foundation')) {
                            const targetSuit = dropTarget.dataset.suit;
                            handleFoundationDrop(targetSuit);
                        }
                    }
                } else if (touchDuration < 300 && touchDistance < 10) {
                    // ì§§ì€ í„°ì¹˜ (í´ë¦­ìœ¼ë¡œ ì²˜ë¦¬)
                    handleCardClick(e);
                }
                
                // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
                const cardEl = e.target;
                if (cardEl) {
                    cardEl.classList.remove('dragging');
                }
                draggedCard = null;
                draggedFrom = null;
                isTouchDragging = false;
                
                // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
                document.querySelectorAll('.column, .foundation').forEach(el => {
                    el.classList.remove('drag-over');
                });
            }

            // ê²Œì„ ì‹œì‘
            newGame();
        </script>
    </div>
</body>
</html> 