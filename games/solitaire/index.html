<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†”ë¦¬í…Œì–´ í´ë˜ì‹ - ì›¹ê²Œì„ ëª¨ìŒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background: linear-gradient(135deg, #0f4c29 0%, #2d5a3d 50%, #1a4c37 100%);
            min-height: 100vh;
            color: white;
            overflow-x: auto;
            padding: 10px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .back-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            z-index: 1000;
            transition: all 0.3s ease;
        }

        .back-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .game-header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .game-info {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            font-size: 1.1rem;
            flex-wrap: wrap;
        }
        


        .score, .time, .moves {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .score.score-update {
            animation: scoreUpdate 0.5s ease-out;
        }

        @keyframes scoreUpdate {
            0% { transform: scale(1); background: rgba(255, 255, 255, 0.1); }
            50% { transform: scale(1.1); background: rgba(255, 215, 0, 0.3); }
            100% { transform: scale(1); background: rgba(255, 255, 255, 0.1); }
        }



        .game-container {
            max-width: 1600px;
            margin: 0 auto;
            min-width: 1200px;
        }

        .top-area {
            display: flex;
            justify-content: space-between;
            margin-bottom: 50px;
            height: 190px;
            width: 1030px;
            margin-left: auto;
            margin-right: auto;
            margin-bottom: 50px;
        }

        .deck-area {
            display: flex;
            gap: 20px;
        }

        .foundation-area {
            display: flex;
            gap: 20px;
        }

        .tableau-area {
            display: flex;
            gap: 20px;
            justify-content: flex-start;
            min-height: 500px;
            width: 1030px;
            margin: 0 auto;
        }

        .card-slot {
            width: 130px;
            height: 180px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.1);
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        #waste {
            width: 180px; /* 3ì¥ ê²¹ì³ì„œ í‘œì‹œí•  ê³µê°„ í™•ë³´ */
        }

        .card-slot:hover {
            border-color: rgba(255, 255, 255, 0.6);
            background: rgba(255, 255, 255, 0.2);
        }
        
        #stock:empty:hover {
            border-color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1);
        }

        .card-slot.highlight {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }
        
        .foundation.drag-over {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .column {
            width: 130px;
            min-height: 180px;
            position: relative;
        }
        
        .column.empty {
            border: 2px dashed rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            height: 180px;
            max-height: 180px;
        }
        
        .column.empty:hover {
            border-color: rgba(255, 255, 255, 0.7);
            background: rgba(255, 255, 255, 0.1);
        }
        
        .column.empty.drag-over {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        .card {
            width: 130px;
            height: 180px;
            border-radius: 12px;
            position: absolute;
            cursor: pointer;
            transition: all 0.3s ease-out;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            border: none;
            background: transparent;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 0;
            font-size: 1.2rem;
            font-weight: bold;
            user-select: none;
        }

        .card:hover:not(.face-down) {
            transform: translateY(-8px) scale(1.02);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
        }

        .card.dragging {
            transform: rotate(5deg) scale(1.05);
            z-index: 1000;
            opacity: 0.8;
            filter: brightness(1.1);
        }

        .card.animating {
            transition: all 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 200;
        }

        .card.flipping {
            transform: rotateY(180deg);
            transition: transform 0.3s;
        }

        .card.flipped {
            transform: rotateY(0deg);
            transition: transform 0.3s;
        }

        .card.auto-complete {
            transition: all 0.3s ease-out;
            z-index: 2000;
        }

        .card.winning {
            animation: cardCelebration 2s ease-out;
        }

        @keyframes cardCelebration {
            0% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-30px) rotate(180deg); }
            100% { transform: translateY(0) rotate(360deg); }
        }

        .card.score-popup {
            animation: scoreFloatUp 1s ease-out forwards;
        }

        @keyframes scoreFloatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.2); opacity: 0; }
        }



        .card-stack {
            position: relative;
        }

        .card-stack .card {
            transition: all 0.3s ease-out;
        }

        .card.move-animation-normal {
            transition: all 0.4s ease-out;
            z-index: 1000;
        }

        .card.move-animation-fast {
            transition: all 0.15s ease-out;
            z-index: 1000;
        }

        .card.face-down {
            background: transparent;
            color: white;
            justify-content: center;
            font-size: 2rem;
        }

        .card.red {
            color: #d32f2f;
        }

        .card.black {
            color: #000;
        }

        .card-number {
            font-size: 0.8rem;
            font-weight: bold;
        }

        .card-suit {
            font-size: 1.2rem;
        }

        .card-center {
            font-size: 2rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }

        .btn {
            background: linear-gradient(45deg, #9B59B6, #8E44AD);
            border: none;
            padding: 10px 15px;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(155, 89, 182, 0.4);
        }

        .win-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .win-content {
            background: linear-gradient(135deg, #2d5a3d, #0f4c29);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 2px solid #ffd700;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .win-title {
            font-size: 3rem;
            margin-bottom: 20px;
            color: #ffd700;
        }

        .win-stats {
            font-size: 1.2rem;
            margin: 20px 0;
            line-height: 1.6;
        }

        /* ì¹´ë“œ ì´ë¯¸ì§€ ì§€ì› */
        .card.with-image {
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        
        .card.with-image .card-content,
        .card.with-image .rank,
        .card.with-image .suit,
        .card.with-image .card-suits {
            display: none;
        }

        .card.face-down.with-image {
            background-image: url('./cards/back.png');
        }

        /* ë°˜ì‘í˜• ë””ìì¸ */
        @media (max-width: 1200px) {
            .game-container {
                min-width: 900px;
            }
            
            .card, .card-slot, .column {
                width: 95px;
            }
            
            .card, .card-slot {
                height: 132px;
            }
            
            #waste {
                width: 130px;
            }
            
            .deck-area, .foundation-area {
                gap: 18px;
            }
            
            .tableau-area {
                gap: 18px;
            }
        }

        @media (max-width: 1024px) {
            .game-container {
                min-width: 800px;
            }
            
            .card, .card-slot, .column {
                width: 85px;
            }
            
            .card, .card-slot {
                height: 118px;
            }
            
            #waste {
                width: 120px;
            }
            
            .deck-area, .foundation-area {
                gap: 15px;
            }
            
            .tableau-area {
                gap: 15px;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                min-width: 700px;
            }
            
            .card, .card-slot, .column {
                width: 75px;
            }
            
            .card, .card-slot {
                height: 104px;
            }
            
            #waste {
                width: 110px;
            }
            
            .game-title {
                font-size: 2rem;
            }
            
            .deck-area, .foundation-area {
                gap: 12px;
            }
            
            .tableau-area {
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <a href="../../index.html" class="back-btn">â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
    
    <div class="controls">
        <button class="btn" onclick="newGame()">ìƒˆ ê²Œì„</button>
    </div>

    <div class="game-header">
        <h1 class="game-title">ğŸƒ ì†”ë¦¬í…Œì–´ í´ë˜ì‹</h1>
        <div class="game-info">
            <div class="score">ì ìˆ˜: <span id="score">0</span></div>
            <div class="time">ì‹œê°„: <span id="time">00:00</span></div>
            <div class="moves">ì›€ì§ì„: <span id="moves">0</span></div>
        </div>

    </div>

    <div class="game-container">
        <!-- ìƒë‹¨ ì˜ì—­: ë±ê³¼ íŒŒìš´ë°ì´ì…˜ -->
        <div class="top-area">
            <div class="deck-area">
                <div class="card-slot" id="stock" onclick="drawCard()">
                </div>
                <div class="card-slot" id="waste"></div>
            </div>
            
            <div class="foundation-area">
                <div class="card-slot foundation" data-suit="hearts">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™¥</div>
                </div>
                <div class="card-slot foundation" data-suit="diamonds">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™¦</div>
                </div>
                <div class="card-slot foundation" data-suit="clubs">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™£</div>
                </div>
                <div class="card-slot foundation" data-suit="spades">
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">â™ </div>
                </div>
            </div>
        </div>

        <!-- í•˜ë‹¨ ì˜ì—­: 7ê°œ ì»¬ëŸ¼ -->
        <div class="tableau-area">
            <div class="column" data-column="0"></div>
            <div class="column" data-column="1"></div>
            <div class="column" data-column="2"></div>
            <div class="column" data-column="3"></div>
            <div class="column" data-column="4"></div>
            <div class="column" data-column="5"></div>
            <div class="column" data-column="6"></div>
        </div>
    </div>

    <!-- ìŠ¹ë¦¬ ëª¨ë‹¬ -->
    <div class="win-modal" id="winModal">
        <div class="win-content">
            <div class="win-title">ğŸ‰ ì¶•í•˜í•©ë‹ˆë‹¤! ğŸ‰</div>
            <div class="win-stats">
                <div>ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span>ì </div>
                <div>í”Œë ˆì´ ì‹œê°„: <span id="finalTime">00:00</span></div>
                <div>ì´ ì›€ì§ì„: <span id="finalMoves">0</span>ë²ˆ</div>
            </div>
            <button class="btn" onclick="closeWinModal()" style="margin: 10px; font-size: 1.1rem; padding: 12px 20px;">ê³„ì†í•˜ê¸°</button>
            <button class="btn" onclick="newGame(); closeWinModal();" style="margin: 10px; font-size: 1.1rem; padding: 12px 20px;">ìƒˆ ê²Œì„</button>
        </div>
    </div>

    <script>
        // ê²Œì„ ìƒíƒœ
        let deck = [];
        let stock = [];
        let waste = [];
        let foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
        let tableau = [[], [], [], [], [], [], []];
        let score = 0;
        let moves = 0;
        let startTime = Date.now();
        let gameWon = false;
        let draggedCard = null;
        let draggedFrom = null;
        let drawCount = 0; // ë½‘ê¸° íšŸìˆ˜ ì¶”ì 
        
        // ë”ë¸”í´ë¦­ ì²˜ë¦¬ ì¤‘ í”Œë˜ê·¸ (ì¤‘ë³µ ë°©ì§€)
        let isProcessingDoubleClick = false;
        
        // ì‹¤í–‰ ì·¨ì†Œ ì‹œìŠ¤í…œ
        let gameHistory = [];
        let maxHistorySize = 50;
        
        // ë§ˆìš°ìŠ¤ ìš°í´ë¦­ ë°©ì§€
        document.addEventListener('contextmenu', (e) => e.preventDefault());
        
        // ê²Œì„ ìƒíƒœ ì €ì¥
        function saveGameState() {
            const gameState = {
                stock: JSON.parse(JSON.stringify(stock)),
                waste: JSON.parse(JSON.stringify(waste)),
                foundations: JSON.parse(JSON.stringify(foundations)),
                tableau: JSON.parse(JSON.stringify(tableau)),
                score: score,
                moves: moves,
                drawCount: drawCount
            };
            
            gameHistory.push(gameState);
            
            // íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ
            if (gameHistory.length > maxHistorySize) {
                gameHistory.shift();
            }
        }
        
        // ì‹¤í–‰ ì·¨ì†Œ
        function undoMove() {
            if (gameHistory.length === 0) return;
            
            const previousState = gameHistory.pop();
            
            stock = previousState.stock;
            waste = previousState.waste;
            foundations = previousState.foundations;
            tableau = previousState.tableau;
            score = previousState.score;
            moves = previousState.moves;
            drawCount = previousState.drawCount;
            
            isProcessingDoubleClick = false; // ë”ë¸”í´ë¦­ í”Œë˜ê·¸ ì´ˆê¸°í™”
            
            renderGame();
        }
        
        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undoMove();
            }
            if (e.key === 'F2') {
                e.preventDefault();
                newGame();
            }
        });
        
        // ì ìˆ˜ ì¦ê°€ ì• ë‹ˆë©”ì´ì…˜
        function animateScoreIncrease(points) {
            const scoreEl = document.querySelector('.score');
            scoreEl.classList.remove('score-update');
            void scoreEl.offsetWidth; // ê°•ì œ ë¦¬í”Œë¡œìš°
            scoreEl.classList.add('score-update');
        }

        // ì¹´ë“œ ìƒì„±
        function createDeck() {
            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            const ranks = ['ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'jack', 'queen', 'king'];
            deck = [];

            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({
                        suit: suit,
                        rank: rank,
                        value: rank === 'ace' ? 1 : 
                               rank === 'jack' ? 11 : 
                               rank === 'queen' ? 12 : 
                               rank === 'king' ? 13 : 
                               parseInt(rank),
                        color: (suit === 'hearts' || suit === 'diamonds') ? 'red' : 'black',
                        faceUp: false
                    });
                }
            }
        }

        // ë± ì„ê¸°
        function shuffleDeck() {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        }

        // ì¹´ë“œ ìš”ì†Œ ìƒì„± (ìµœì í™”)
        function createCardElement(card) {
            if (!card || !card.suit || !card.rank) return null;
            
            const cardEl = document.createElement('div');
            cardEl.className = `card ${card.color}`;
            cardEl.draggable = true;
            
            if (card.faceUp) {
                const imagePath = `./cards/${card.suit}-${card.rank}.png`;
                cardEl.style.backgroundImage = `url('${imagePath}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.classList.add('with-image');
                cardEl.innerHTML = '';
            } else {
                cardEl.classList.add('face-down', 'with-image');
                cardEl.style.backgroundImage = `url('./cards/back.png')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.innerHTML = '';
            }

            cardEl.addEventListener('dragstart', handleDragStart);
            cardEl.addEventListener('click', handleCardClick);
            cardEl.addEventListener('mousedown', handleCardClick);
            
            return cardEl;
        }

        // ì¹´ë“œ í‘œì‹œ ë­í¬
        function getDisplayRank(rank) {
            switch(rank) {
                case 'ace': return 'A';
                case 'jack': return 'J';
                case 'queen': return 'Q';
                case 'king': return 'K';
                default: return rank;
            }
        }

        // ìˆ˜íŠ¸ ì‹¬ë³¼
        function getSuitSymbol(suit) {
            switch(suit) {
                case 'hearts': return 'â™¥';
                case 'diamonds': return 'â™¦';
                case 'clubs': return 'â™£';
                case 'spades': return 'â™ ';
                default: return suit;
            }
        }



        // ê²Œì„ í•´ê²° ê°€ëŠ¥ì„± ì²´í¬
        function checkGameSolvability() {
            let solvabilityScore = 0;
            let issues = [];
            
            // 1. ì—ì´ìŠ¤ë“¤ì˜ ì ‘ê·¼ì„± ì²´í¬
            const suits = ['hearts', 'diamonds', 'clubs', 'spades'];
            let accessibleAces = 0;
            
            suits.forEach(suit => {
                // íƒ€ë¸”ë¡œ ë§¨ ìœ„ ì¹´ë“œë“¤ì—ì„œ ì—ì´ìŠ¤ ì°¾ê¸°
                for (let col = 0; col < 7; col++) {
                    if (tableau[col].length > 0) {
                        const topCard = tableau[col][tableau[col].length - 1];
                        if (topCard.rank === 'ace' && topCard.suit === suit) {
                            accessibleAces++;
                            solvabilityScore += 25;
                        }
                    }
                }
                
                // ìŠ¤í†¡/ì›¨ì´ìŠ¤íŠ¸ì—ì„œ ì—ì´ìŠ¤ ì°¾ê¸° (ì¶”ê°€ ì ìˆ˜)
                const stockHasAce = stock.some(card => card.rank === 'ace' && card.suit === suit);
                const wasteHasAce = waste.some(card => card.rank === 'ace' && card.suit === suit);
                if (stockHasAce || wasteHasAce) {
                    solvabilityScore += 15;
                }
            });
            
            // 2. ê¸°ë³¸ ì´ë™ ê°€ëŠ¥ì„± ì²´í¬
            let possibleMoves = 0;
            
            // íƒ€ë¸”ë¡œ ê°„ ì´ë™ ê°€ëŠ¥ì„±
            for (let sourceCol = 0; sourceCol < 7; sourceCol++) {
                if (tableau[sourceCol].length > 0) {
                    const sourceCard = tableau[sourceCol][tableau[sourceCol].length - 1];
                    if (sourceCard.faceUp) {
                        for (let targetCol = 0; targetCol < 7; targetCol++) {
                            if (sourceCol !== targetCol) {
                                const targetCard = tableau[targetCol].length > 0 ? 
                                    tableau[targetCol][tableau[targetCol].length - 1] : null;
                                if (canPlaceOnTableau(sourceCard, targetCard)) {
                                    possibleMoves++;
                                }
                            }
                        }
                    }
                }
            }
            
            solvabilityScore += possibleMoves * 5;
            
            // 3. í‚¹ë“¤ì˜ ë°°ì¹˜ ìƒíƒœ ì²´í¬
            let kingsInGoodPosition = 0;
            for (let col = 0; col < 7; col++) {
                if (tableau[col].length > 0) {
                    const bottomCard = tableau[col][0];
                    if (bottomCard.rank === 'king') {
                        kingsInGoodPosition++;
                        solvabilityScore += 10;
                    }
                }
            }
            
            // 4. ë’¤ì§‘ì–´ì§„ ì¹´ë“œë“¤ì˜ ìƒíƒœ ì²´í¬
            let hiddenCardRatio = 0;
            let totalCards = 0;
            let hiddenCards = 0;
            
            for (let col = 0; col < 7; col++) {
                totalCards += tableau[col].length;
                hiddenCards += tableau[col].filter(card => !card.faceUp).length;
            }
            
            hiddenCardRatio = totalCards > 0 ? hiddenCards / totalCards : 0;
            solvabilityScore += (1 - hiddenCardRatio) * 20; // ì ì€ ìˆ¨ê²¨ì§„ ì¹´ë“œì¼ìˆ˜ë¡ ì¢‹ìŒ
            

            
            // í•´ê²° ë¶ˆê°€ëŠ¥í•  ê°€ëŠ¥ì„±ì´ ë†’ì€ ê²Œì„ë“¤ í•„í„°ë§
            if (solvabilityScore < 30) {
                issues.push('ì „ì²´ì ìœ¼ë¡œ í•´ê²°í•˜ê¸° ë§¤ìš° ì–´ë ¤ìš´ ë°°ì¹˜');
            }
            if (accessibleAces === 0) {
                issues.push('ì¦‰ì‹œ ì ‘ê·¼ ê°€ëŠ¥í•œ ì—ì´ìŠ¤ê°€ ì—†ìŒ');
            }
            if (possibleMoves === 0) {
                issues.push('ì´ˆê¸° ì´ë™ ê°€ëŠ¥í•œ ì¹´ë“œê°€ ì—†ìŒ');
            }
            if (hiddenCardRatio > 0.8) {
                issues.push('ë„ˆë¬´ ë§ì€ ì¹´ë“œê°€ ë’¤ì§‘ì–´ì ¸ ìˆìŒ');
            }
            
            return {
                score: solvabilityScore,
                solvable: solvabilityScore >= 40 && possibleMoves > 0,
                issues: issues
            };
        }

        // ê²Œì„ ì´ˆê¸°í™” (í•´ê²° ê°€ëŠ¥í•œ ê²Œì„ë§Œ ìƒì„±)
        function newGame() {
            let attempts = 0;
            const maxAttempts = 10; // ìµœëŒ€ 10ë²ˆ ì‹œë„
            
            let gameAnalysis;
            
            do {
                attempts++;
                createDeck();
                shuffleDeck();
                
                // ì´ˆê¸°í™”
                stock = [...deck];
                waste = [];
                foundations = { hearts: [], diamonds: [], clubs: [], spades: [] };
                tableau = [[], [], [], [], [], [], []];
                score = 0;
                moves = 0;
                startTime = Date.now();
                gameWon = false;
                drawCount = 0;
                gameHistory = [];
                isProcessingDoubleClick = false;

                // íƒ€ë¸”ë¡œ ë°°ì¹˜
                let tableauCount = 0;
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        if (stock.length === 0) break;
                        const card = stock.pop();
                        if (!card || !card.suit || !card.rank) continue;
                        if (row === col) {
                            card.faceUp = true;
                        }
                        tableau[col].push(card);
                        tableauCount++;
                    }
                }
                
                // í•´ê²° ê°€ëŠ¥ì„± ì²´í¬
                gameAnalysis = checkGameSolvability();
                
                // í•´ê²° ë¶ˆê°€ëŠ¥í•˜ë©´ ë‹¤ì‹œ ì‹œë„
                
            } while (!gameAnalysis.solvable && attempts < maxAttempts);
            
            // ê²Œì„ ìƒì„± ì™„ë£Œ
            dealCardsWithAnimation();
            updateTimer();
        }

        // ì¼ë°˜ ê²Œì„ í”Œë ˆì´ìš© ì¹´ë“œ ì´ë™ ì• ë‹ˆë©”ì´ì…˜ (ë¶€ë“œëŸ¬ìš´ ì†ë„)
        function animateCardMove(cardElement, targetElement, onComplete) {
            const startRect = cardElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            
            // ì‹œì‘ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const deltaX = targetRect.left - startRect.left;
            const deltaY = targetRect.top - startRect.top;
            
            // ì¼ë°˜ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
            cardElement.classList.add('move-animation-normal');
            
            // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
            cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            
            // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì½œë°± ì‹¤í–‰ (ë¶€ë“œëŸ¬ìš´ 400ms)
            setTimeout(() => {
                cardElement.classList.remove('move-animation-normal');
                cardElement.style.transform = '';
                onComplete();
            }, 400);
        }

        // ìë™ ì™„ì„±ìš© ë¹ ë¥¸ ì—°ì† ì• ë‹ˆë©”ì´ì…˜ (ì¹´ë“œë“¤ì´ ì¤‘ë³µë˜ë©° ì´ë™)
        function autoCompleteAnimateCardMove(cardElement, targetElement, onComplete) {
            const startRect = cardElement.getBoundingClientRect();
            const targetRect = targetElement.getBoundingClientRect();
            
            // ì‹œì‘ ìœ„ì¹˜ì™€ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const deltaX = targetRect.left - startRect.left;
            const deltaY = targetRect.top - startRect.top;
            
            // ë¹ ë¥¸ ì• ë‹ˆë©”ì´ì…˜ í´ë˜ìŠ¤ ì¶”ê°€
            cardElement.classList.add('move-animation-fast');
            
            // ëª©í‘œ ìœ„ì¹˜ë¡œ ì´ë™
            cardElement.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            
            // ë¹ ë¥¸ ì™„ë£Œ í›„ ì½œë°± ì‹¤í–‰ (150ms)
            setTimeout(() => {
                cardElement.classList.remove('move-animation-fast');
                cardElement.style.transform = '';
                onComplete();
            }, 150);
        }

        // ì¹´ë“œ ë½‘ê¸° ì• ë‹ˆë©”ì´ì…˜ (ì›ë˜ ë°©ì‹ + ë§ˆì§€ë§‰ 1-2ì¥ íŠ¹ë³„ ì• ë‹ˆë©”ì´ì…˜)
        function animateCardDraw(drawnCards, isLastFewCards = false) {
            // ê¸°ë³¸ ë Œë”ë§
            renderGame();
            
            if (!drawnCards || drawnCards.length === 0) return;
            
            // ì›¨ì´ìŠ¤íŠ¸ ì˜ì—­ì˜ ìƒˆë¡œ ì¶”ê°€ëœ ì¹´ë“œë“¤ ì°¾ê¸°
            const wasteEl = document.getElementById('waste');
            const newCards = wasteEl.querySelectorAll('.card');
            const startIndex = Math.max(0, newCards.length - drawnCards.length);
            
            // ë°˜ì‘í˜• ì˜¤í”„ì…‹ ê³„ì‚°
            let offset = 25;
            if (window.innerWidth <= 768) {
                offset = 20;
            } else if (window.innerWidth <= 1024) {
                offset = 22;
            } else if (window.innerWidth <= 1200) {
                offset = 23;
            }
            
            // ë§ˆì§€ë§‰ 1-2ì¥ì¼ ë•Œ íŠ¹ë³„í•œ ìŠ¬ë¼ì´ë“œ ì• ë‹ˆë©”ì´ì…˜
            if (isLastFewCards && startIndex > 0) {
                const cardsToAdd = drawnCards.length;
                
                // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜ ìŠ¤íƒ€ì¼ ì œê±° (ê°„ì„­ ë°©ì§€, leftëŠ” ìœ ì§€)
                for (let i = 0; i < newCards.length; i++) {
                    newCards[i].style.position = '';
                    // newCards[i].style.left = ''; // leftëŠ” ìœ ì§€!
                    newCards[i].style.top = '';
                    newCards[i].style.zIndex = '';
                    newCards[i].style.transform = '';
                    newCards[i].style.transition = '';
                }
                
                // ìƒˆ ì¹´ë“œë“¤ ìˆ¨ê¸°ê¸° (ë‚˜ì¤‘ì— ë“±ì¥ì‹œí‚¤ê¸° ìœ„í•´)
                for (let i = startIndex; i < newCards.length; i++) {
                    newCards[i].style.display = 'none';
                }
                
                // ê¸°ì¡´ ì¹´ë“œë“¤ì„ ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¬ê¸° (ì• ë‹ˆë©”ì´ì…˜ ì¤€ë¹„)
                if (startIndex >= 1) {
                    // ì¹´ë“œ2 (í˜„ì¬ aìë¦¬) â†’ ì›ë˜ bìë¦¬ë¡œ
                    newCards[0].style.transform = `translateX(${offset}px)`;
                    newCards[0].style.transition = 'none';
                }
                if (startIndex >= 2) {
                    // ì¹´ë“œ3 (í˜„ì¬ bìë¦¬) â†’ ì›ë˜ cìë¦¬ë¡œ  
                    newCards[1].style.transform = `translateX(${offset}px)`;
                    newCards[1].style.transition = 'none';
                }
                
                // 1ë‹¨ê³„: aìë¦¬ ì¹´ë“œ ì¦‰ì‹œ ì‚¬ë¼ì§
                const originalACard = document.createElement('div');
                originalACard.className = newCards[0].className;
                originalACard.innerHTML = newCards[0].innerHTML;
                originalACard.style.cssText = newCards[0].style.cssText;
                originalACard.style.transform = 'translateX(0px)';
                wasteEl.appendChild(originalACard);
                
                originalACard.style.display = 'none'; // ì¦‰ì‹œ ì‚¬ë¼ì§
                
                // 2ë‹¨ê³„: ê¸°ì¡´ ì¹´ë“œë“¤ ë¶€ë“œëŸ½ê²Œ ìŠ¬ë¼ì´ë“œ (100ms í›„ ì‹œì‘)
                setTimeout(() => {
                    // ì¹´ë“œ2: bìë¦¬ â†’ aìë¦¬
                    if (newCards[0]) {
                        newCards[0].style.transition = 'transform 0.25s ease-out';
                        newCards[0].style.transform = 'translateX(0px)';
                    }
                    // ì¹´ë“œ3: cìë¦¬ â†’ bìë¦¬ (startIndex=2ì¼ ë•Œë„ ì›€ì§ì—¬ì•¼ í•¨)
                    if (newCards[1] && startIndex >= 2) {
                        newCards[1].style.transition = 'transform 0.25s ease-out';
                        newCards[1].style.transform = 'translateX(0px)';
                    }
                }, 100);
                
                // 3ë‹¨ê³„: ìƒˆ ì¹´ë“œ ë“±ì¥ (ê¸°ì¡´ ì¹´ë“œ ì´ë™ ì™„ë£Œ í›„)
                setTimeout(() => {
                    for (let i = startIndex; i < newCards.length; i++) {
                        const cardEl = newCards[i];
                        cardEl.style.display = ''; // ì¹´ë“œ ë‹¤ì‹œ í‘œì‹œ
                        cardEl.style.transform = `translateX(-${offset}px)`; // bìë¦¬ì—ì„œ ì‹œì‘
                        cardEl.style.transition = 'none';
                        
                        setTimeout(() => {
                            cardEl.style.transition = 'transform 0.25s ease-out';
                            cardEl.style.transform = `translateX(0px)`; // ìµœì¢… ìœ„ì¹˜ë¡œ
                        }, 50);
                    }
                }, 400); // 2ë‹¨ê³„ ì™„ë£Œ í›„ ì‹œì‘ (100ms + 250ms + 50ms ì—¬ìœ )
                
                // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì •ë¦¬
                setTimeout(() => {
                    // ìƒˆ ì¹´ë“œë“¤ë§Œ transform ì´ˆê¸°í™” (ê¸°ì¡´ ì¹´ë“œë“¤ì€ ì´ë™ ìƒíƒœ ìœ ì§€)
                    for (let i = startIndex; i < newCards.length; i++) {
                        newCards[i].style.transform = '';
                        newCards[i].style.transition = '';
                    }
                    // ëª¨ë“  ì¹´ë“œì˜ displayì™€ transition ì •ë¦¬
                    newCards.forEach(cardEl => {
                        cardEl.style.display = '';
                        cardEl.style.transition = '';
                    });
                    // ì„ì‹œ ì¹´ë“œ ì œê±°
                    if (originalACard && originalACard.parentNode) {
                        originalACard.remove();
                    }
                    renderGame();
                }, 650); // ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ (100ms + 250ms + 50ms + 250ms)
                
                return;
            }
            
            // ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜ (3ì¥ì”© ë½‘ì„ ë•Œ) - ì ˆëŒ€ ê±´ë“œë¦¬ì§€ ì•ŠìŒ
            // ìƒˆë¡œìš´ ì¹´ë“œë“¤ì„ ëª¨ë‘ ì™¼ìª½ ëì— ê²¹ì³ì„œ ìœ„ì¹˜ì‹œí‚¤ê¸°
            for (let i = startIndex; i < newCards.length; i++) {
                const cardEl = newCards[i];
                const cardOrder = i - startIndex;
                
                // ëª¨ë“  ì¹´ë“œë¥¼ ì™¼ìª½ ëì— ê²¹ì³ì„œ ìœ„ì¹˜
                cardEl.style.position = 'absolute';
                cardEl.style.left = '0px';
                cardEl.style.top = '0px';
                cardEl.style.zIndex = cardOrder.toString();
                cardEl.style.transition = 'transform 0.4s ease-out';
                cardEl.style.transform = 'translateX(0)';
            }
            
            // ë§¨ ìœ„ ì¹´ë“œë¶€í„° ì‹œì‘í•´ì„œ ì „ì²´ê°€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ìŠ¬ë¼ì´ë“œí•˜ë©´ì„œ í¼ì³ì§€ê¸°
            setTimeout(() => {
                // ë§¨ ìœ„ ì¹´ë“œ(ë§ˆì§€ë§‰ ì¹´ë“œ)ê°€ ë¨¼ì € ì›€ì§ì´ê¸° ì‹œì‘
                const topCardIndex = newCards.length - 1;
                const topCardOrder = topCardIndex - startIndex;
                const topCard = newCards[topCardIndex];
                
                if (topCard) {
                    // ë§¨ ìœ„ ì¹´ë“œë¥¼ ìµœì¢… ìœ„ì¹˜ë¡œ ì´ë™
                    topCard.style.transform = `translateX(${topCardOrder * offset}px)`;
                }
                
                // ë‚˜ë¨¸ì§€ ì¹´ë“œë“¤ì´ ìì—°ìŠ¤ëŸ½ê²Œ ë”°ë¼ê°€ë©´ì„œ í¼ì³ì§€ê¸°
                for (let i = startIndex; i < newCards.length - 1; i++) {
                    const cardEl = newCards[i];
                    const cardOrder = i - startIndex;
                    
                    setTimeout(() => {
                        // ê° ì¹´ë“œë¥¼ ìµœì¢… ìœ„ì¹˜ë¡œ ìŠ¬ë¼ì´ë“œ
                        cardEl.style.transform = `translateX(${cardOrder * offset}px)`;
                    }, cardOrder * 80);
                }
                
                // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤íƒ€ì¼ ì •ë¦¬
                setTimeout(() => {
                    for (let i = startIndex; i < newCards.length; i++) {
                        const cardEl = newCards[i];
                        cardEl.style.position = '';
                        cardEl.style.transition = '';
                        cardEl.style.transform = '';
                        // leftì™€ zIndexëŠ” ê¸°ë³¸ ë Œë”ë§ì—ì„œ ì„¤ì •ë¨
                    }
                    // ìµœì¢… ë Œë”ë§ìœ¼ë¡œ ì •ë¦¬
                    renderGame();
                }, 300 + (drawnCards.length - 1) * 60);
            }, 100);
        }

        // ê²Œì„ ì‹œì‘ì‹œ ì¹´ë“œ ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜
        function dealCardsWithAnimation() {
            // ë¨¼ì € í™”ë©´ì„ í´ë¦¬ì–´í•˜ê³  ê¸°ë³¸ ë Œë”ë§
            renderGame();
            
            // ì ì‹œ í›„ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°)
            setTimeout(() => {
                // ìŠ¤í†¡ ìœ„ì¹˜ ì¢Œí‘œ (ê¸°ì¤€ì )
                const stockEl = document.getElementById('stock');
                const stockRect = stockEl.getBoundingClientRect();
                
                // ëª¨ë“  íƒ€ë¸”ë¡œ ì¹´ë“œë“¤ì„ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ëª¨ìœ¼ê¸°
                const allTableauCards = document.querySelectorAll('.column .card');
                
                // ì¹´ë“œë“¤ì„ ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ ì •ë ¬ (ë’·ë©´ë¶€í„° ë°°ì¹˜ë˜ë„ë¡)
                const cardsToAnimate = [];
                for (let col = 0; col < 7; col++) {
                    for (let row = 0; row <= col; row++) {
                        const card = document.querySelector(`.column[data-column="${col}"] .card:nth-child(${row + 1})`);
                        if (card) {
                            cardsToAnimate.push({ card, col, row, order: cardsToAnimate.length });
                        }
                    }
                }
                
                // ëª¨ë“  ì¹´ë“œë¥¼ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì´ë™
                cardsToAnimate.forEach((item, index) => {
                    const cardRect = item.card.getBoundingClientRect();
                    const deltaX = stockRect.left - cardRect.left;
                    const deltaY = stockRect.top - cardRect.top;
                    
                    // ì¹´ë“œë¥¼ ìŠ¤í†¡ ìœ„ì¹˜ë¡œ ì¦‰ì‹œ ì´ë™ (ì™„ì „íˆ ë­‰ì³ìˆê²Œ)
                    item.card.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                    item.card.style.transition = 'none';
                    item.card.style.zIndex = (1000 + index).toString(); // ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ z-index
                });
                
                // ì¹´ë“œ ë’·ë©´ì„ ë§¨ ìœ„ë¡œ (ìŠ¤í†¡ ì¹´ë“œ)
                const stockCard = stockEl.querySelector('.card');
                if (stockCard) {
                    stockCard.style.zIndex = '2000'; // ê°€ì¥ ìœ„ì—
                }
                
                // ìˆœì°¨ì ìœ¼ë¡œ ì¹´ë“œ ë°°ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ë’·ë©´ë¶€í„° ì •ëˆë˜ê²Œ)
                setTimeout(() => {
                    let delay = 0;
                    
                    // ë°°ì¹˜ ìˆœì„œëŒ€ë¡œ ì¹´ë“œë“¤ì„ ê°ì ì›ë˜ ìœ„ì¹˜ë¡œ ìŠ¬ë¼ì´ë“œ
                    cardsToAnimate.forEach((item, index) => {
                        setTimeout(() => {
                            // íŠ¸ëœì§€ì…˜ ì„¤ì • (ë” ë¶€ë“œëŸ½ê³  ë¹ ë¥´ê²Œ)
                            item.card.style.transition = 'transform 0.4s ease-out';
                            
                            // ì›ë˜ ìœ„ì¹˜ë¡œ ë˜ëŒë¦¬ê¸°
                            item.card.style.transform = 'translate(0, 0)';
                            
                            // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤íƒ€ì¼ ì œê±°
                            setTimeout(() => {
                                item.card.style.transform = '';
                                item.card.style.transition = '';
                                item.card.style.zIndex = '';
                            }, 400);
                        }, delay);
                        delay += 40; // ê° ì¹´ë“œë§ˆë‹¤ 40ms ê°„ê²© (ë” ë¹ ë¥´ê³  ë§¤ë„ëŸ½ê²Œ)
                    });
                    
                    // ëª¨ë“  ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ìŠ¤í†¡ ì¹´ë“œ z-index ì›ë³µ
                    setTimeout(() => {
                        if (stockCard) {
                            stockCard.style.zIndex = '';
                        }
                    }, delay + 400);
                }, 300); // ì¹´ë“œë“¤ì´ ë­‰ì¹œ í›„ 300ms ëŒ€ê¸°
            }, 100); // ë Œë”ë§ ì™„ë£Œ ëŒ€ê¸°
        }

        // ê²Œì„ ë Œë”ë§
        function renderGame() {
            // ìŠ¤í†¡ ë Œë”ë§
            const stockEl = document.getElementById('stock');
            stockEl.innerHTML = '';
            
            // ê¸°ì¡´ í´ë¦­ ì´ë²¤íŠ¸ ì œê±°
            stockEl.onclick = null;
            
            if (stock.length > 0) {
                // ë’·ë©´ ì¹´ë“œ ìƒì„±
                const backCard = document.createElement('div');
                backCard.className = 'card face-down with-image';
                backCard.innerHTML = '';
                backCard.style.backgroundImage = `url('./cards/back.png')`;
                backCard.style.position = 'absolute';
                backCard.style.top = '0';
                backCard.style.left = '0';
                backCard.style.cursor = 'pointer';
                // ì¹´ë“œì—ë§Œ í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²° (ì´ë²¤íŠ¸ ë²„ë¸”ë§ ë°©ì§€)
                backCard.onclick = function(e) {
                    e.stopPropagation();
                    drawCard();
                };
                stockEl.appendChild(backCard);
            } else {
                // ìŠ¤í†¡ì´ ë¹„ì—ˆì„ ë•Œë§Œ ìŠ¬ë¡¯ì— í´ë¦­ ì´ë²¤íŠ¸ ì—°ê²°
                stockEl.onclick = function(e) {
                    e.stopPropagation();
                    drawCard();
                };
                stockEl.style.cursor = waste.length > 0 ? 'pointer' : 'default';
            }

            // ì›¨ì´ìŠ¤íŠ¸ ë Œë”ë§ (ìµœëŒ€ 3ì¥ ê²¹ì³ì„œ í‘œì‹œ)
            const wasteEl = document.getElementById('waste');
            wasteEl.innerHTML = '';
            if (waste.length > 0) {
                waste = waste.filter(card => card && card.suit && card.rank);
                
                if (waste.length > 0) {
                    const visibleCount = Math.min(3, waste.length);
                    const startIndex = waste.length - visibleCount;
                    let renderedCount = 0;
                    
                    for (let i = 0; i < visibleCount; i++) {
                        const cardIndex = startIndex + i;
                        const card = waste[cardIndex];
                        const cardEl = createCardElement(card);
                        
                        if (!cardEl) continue;
                        
                        cardEl.style.position = 'absolute';
                        cardEl.style.top = '0';
                        
                        // ë°˜ì‘í˜• ì˜¤í”„ì…‹
                        let offset = 25;
                        if (window.innerWidth <= 768) {
                            offset = 20;
                        } else if (window.innerWidth <= 1024) {
                            offset = 22;
                        } else if (window.innerWidth <= 1200) {
                            offset = 23;
                        }
                        
                        cardEl.style.left = `${renderedCount * offset}px`;
                        cardEl.style.zIndex = renderedCount + 1;
                        
                        // ë§¨ ìœ„ ì¹´ë“œ(ë§ˆì§€ë§‰ ì¹´ë“œ)ë§Œ ë“œë˜ê·¸ ê°€ëŠ¥í•˜ê³  ì´ë²¤íŠ¸ ì¶”ê°€
                        if (i === visibleCount - 1) {
                            cardEl.classList.add('waste-card');
                            cardEl.dataset.wasteCard = 'true';
                            cardEl.dataset.wasteIndex = cardIndex;
                            cardEl.style.zIndex = 100;
                            
                            // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ì „ìš© ë“œë˜ê·¸ ì´ë²¤íŠ¸
                            cardEl.addEventListener('dragstart', (e) => {
                                document.querySelectorAll('.column, .foundation').forEach(el => {
                                    el.classList.remove('drag-over');
                                });
                                
                                draggedCard = { index: waste.length - 1 };
                                draggedFrom = 'waste';
                                cardEl.classList.add('dragging');
                                e.dataTransfer.effectAllowed = 'move';
                            });
                            
                            // ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™
                            cardEl.addEventListener('dblclick', () => {
                                if (isProcessingDoubleClick || waste.length === 0) return;
                                
                                const card = waste[waste.length - 1];
                                if (!card || !card.suit || !card.rank) return;
                                
                                if (canPlaceOnFoundation(card, card.suit)) {
                                    isProcessingDoubleClick = true;
                                    const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                                    
                                    animateCardMove(cardEl, targetFoundation, () => {
                                        if (waste.length > 0 && waste[waste.length - 1] === card) {
                                            saveGameState();
                                            waste.pop();
                                            foundations[card.suit].push(card);
                                            moves++;
                                            score += 10;
                                            animateScoreIncrease(10);
                                            renderGame();
                                            checkWin();
                                            checkAutoComplete();
                                        }
                                        isProcessingDoubleClick = false;
                                    });
                                }
                            });
                        } else {
                            cardEl.draggable = false;
                            cardEl.style.cursor = 'default';
                        }
                        
                        wasteEl.appendChild(cardEl);
                        renderedCount++;
                    }
                }
            }

            // íŒŒìš´ë°ì´ì…˜ ë Œë”ë§
            for (let suit in foundations) {
                const foundationEl = document.querySelector(`.foundation[data-suit="${suit}"]`);
                foundationEl.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2rem; opacity: 0.3;">${getSuitSymbol(suit)}</div>`;
                
                if (foundations[suit].length > 0) {
                    const topCard = foundations[suit][foundations[suit].length - 1];
                    const cardEl = createCardElement(topCard);
                    foundationEl.appendChild(cardEl);
                }
            }

            // íƒ€ë¸”ë¡œ ë Œë”ë§
            for (let col = 0; col < 7; col++) {
                const columnEl = document.querySelector(`.column[data-column="${col}"]`);
                columnEl.innerHTML = '';
                
                // ë¹ˆ ì»¬ëŸ¼ í‘œì‹œ
                if (tableau[col].length === 0) {
                    columnEl.classList.add('empty');
                } else {
                    columnEl.classList.remove('empty');
                }
                
                tableau[col].forEach((card, index) => {
                    const cardEl = createCardElement(card);
                    
                    // ë°˜ì‘í˜• ì¹´ë“œ ê°„ê²©
                    let cardOffset = 30;
                    if (window.innerWidth <= 768) {
                        cardOffset = 25;
                    } else if (window.innerWidth <= 1024) {
                        cardOffset = 27;
                    } else if (window.innerWidth <= 1200) {
                        cardOffset = 28;
                    }
                    
                    cardEl.style.top = `${index * cardOffset}px`;
                    cardEl.style.zIndex = index;
                    cardEl.dataset.column = col;
                    cardEl.dataset.index = index;
                    
                    // íƒ€ë¸”ë¡œ ì¹´ë“œ ë”ë¸”í´ë¦­ìœ¼ë¡œ ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™ (ë§¨ ìœ„ ì¹´ë“œë§Œ, ì•ˆì „ì¥ì¹˜ ì¶”ê°€)
                    if (card.faceUp && index === tableau[col].length - 1) {
                        cardEl.addEventListener('dblclick', () => {
                            // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
                            if (isProcessingDoubleClick) {
                                return;
                            }
                            
                            // í˜„ì¬ ì¹´ë“œê°€ ì—¬ì „íˆ í•´ë‹¹ ìœ„ì¹˜ì— ìˆëŠ”ì§€ í™•ì¸
                            if (tableau[col].length <= index || tableau[col][index] !== card) {
                                return;
                            }
                            
                            // ë§¨ ìœ„ ì¹´ë“œì¸ì§€ ë‹¤ì‹œ í™•ì¸
                            if (index !== tableau[col].length - 1) {
                                return;
                            }
                            
                            if (!card || !card.suit || !card.rank) {
                                return;
                            }
                            
                            if (canPlaceOnFoundation(card, card.suit)) {
                                isProcessingDoubleClick = true; // ì²˜ë¦¬ ì‹œì‘
                                const targetFoundation = document.querySelector(`.foundation[data-suit="${card.suit}"]`);
                                
                                // ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì´ë™
                                animateCardMove(cardEl, targetFoundation, () => {
                                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì‹œì ì— ë‹¤ì‹œ í•œ ë²ˆ í™•ì¸
                                    if (tableau[col].length > index && tableau[col][index] === card) {
                                        saveGameState();
                                        tableau[col].splice(index, 1);
                                        
                                        // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                                        if (tableau[col].length > 0) {
                                            const lastCard = tableau[col][tableau[col].length - 1];
                                            if (!lastCard.faceUp) {
                                                lastCard.faceUp = true;
                                                score += 5;
                                            }
                                        }
                                        
                                                                foundations[card.suit].push(card);
                        moves++;
                        score += 10;
                        animateScoreIncrease(10);
                        renderGame();
                        checkWin();
                        checkAutoComplete();
                                    }
                                    isProcessingDoubleClick = false; // ì²˜ë¦¬ ì™„ë£Œ
                                });
                            }
                        });
                    }
                    
                    columnEl.appendChild(cardEl);
                });
            }

            // ë“œë¡­ ì¡´ ì¶”ê°€
            addDropListeners();
            updateScore();
        }

        // ë“œë¡­ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        function addDropListeners() {
            // íƒ€ë¸”ë¡œ ë“œë¡­
            document.querySelectorAll('.column').forEach(col => {
                col.addEventListener('dragover', handleDragOver);
                col.addEventListener('drop', handleDrop);
                col.addEventListener('dragleave', handleDragLeave);
            });

            // íŒŒìš´ë°ì´ì…˜ ë“œë¡­
            document.querySelectorAll('.foundation').forEach(foundation => {
                foundation.addEventListener('dragover', handleDragOver);
                foundation.addEventListener('drop', handleDrop);
                foundation.addEventListener('dragleave', handleDragLeave);
            });
        }
        
        // ë“œë˜ê·¸ ë¦¬ë¸Œ
        function handleDragLeave(e) {
            // ì»¨í…Œì´ë„ˆë¥¼ ì™„ì „íˆ ë²—ì–´ë‚¬ì„ ë•Œë§Œ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            if (!e.currentTarget.contains(e.relatedTarget)) {
                e.currentTarget.classList.remove('drag-over');
            }
        }

        // ë“œë˜ê·¸ ì‹œì‘
        function handleDragStart(e) {
            const cardEl = e.target;
            const col = parseInt(cardEl.dataset.column);
            const index = parseInt(cardEl.dataset.index);
            
            // ê¸°ì¡´ í•˜ì´ë¼ì´íŠ¸ ì œê±°
            document.querySelectorAll('.column, .foundation').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            // íƒ€ë¸”ë¡œ ì¹´ë“œ ë“œë˜ê·¸ë§Œ ì²˜ë¦¬ (ì›¨ì´ìŠ¤íŠ¸ëŠ” ì „ìš© ë¦¬ìŠ¤ë„ˆ ì‚¬ìš©)
            if (col !== undefined && index !== undefined) {
                const card = tableau[col][index];
                if (card && card.faceUp) {
                    draggedCard = { col, index };
                    draggedFrom = 'tableau';
                    cardEl.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                }
            }
        }

        // ë“œë˜ê·¸ ì˜¤ë²„
        function handleDragOver(e) {
            e.preventDefault();
            
            if (!draggedCard) return;
            
            const dropTarget = e.target.closest('.column, .foundation');
            if (!dropTarget) return;
            
            // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
            document.querySelectorAll('.column, .foundation').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            // ìœ íš¨í•œ ë“œë¡­ ìœ„ì¹˜ì¸ì§€ í™•ì¸í•˜ê³  í•˜ì´ë¼ì´íŠ¸
            if (dropTarget.classList.contains('column')) {
                const targetCol = parseInt(dropTarget.dataset.column);
                const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;
                
                let card = null;
                if (draggedFrom === 'tableau') {
                    const { col: sourceCol, index } = draggedCard;
                    if (sourceCol !== targetCol) {
                        card = tableau[sourceCol][index];
                    }
                } else if (draggedFrom === 'waste') {
                    card = waste[draggedCard.index];
                }
                
                if (card && canPlaceOnTableau(card, targetCard)) {
                    dropTarget.classList.add('drag-over');
                }
            } else if (dropTarget.classList.contains('foundation')) {
                const targetSuit = dropTarget.dataset.suit;
                
                let card = null;
                if (draggedFrom === 'tableau') {
                    const { col, index } = draggedCard;
                    if (index === tableau[col].length - 1) {
                        card = tableau[col][index];
                    }
                } else if (draggedFrom === 'waste') {
                    card = waste[draggedCard.index];
                }
                
                if (card && canPlaceOnFoundation(card, targetSuit)) {
                    dropTarget.classList.add('drag-over');
                }
            }
        }

        // ë“œë¡­ ì²˜ë¦¬
        function handleDrop(e) {
            e.preventDefault();
            
            if (!draggedCard) return;

            const dropTarget = e.target.closest('.column, .foundation');
            if (!dropTarget) return;

            if (dropTarget.classList.contains('column')) {
                const targetCol = parseInt(dropTarget.dataset.column);
                handleTableauDrop(targetCol);
            } else if (dropTarget.classList.contains('foundation')) {
                const targetSuit = dropTarget.dataset.suit;
                handleFoundationDrop(targetSuit);
            }

            // ë“œë˜ê·¸ ìƒíƒœ ì´ˆê¸°í™”
            document.querySelectorAll('.card.dragging').forEach(card => {
                card.classList.remove('dragging');
            });
            
            // ëª¨ë“  í•˜ì´ë¼ì´íŠ¸ ì œê±°
            document.querySelectorAll('.column, .foundation').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            draggedCard = null;
            draggedFrom = null;
        }

        // íƒ€ë¸”ë¡œ ë“œë¡­ ì²˜ë¦¬
        function handleTableauDrop(targetCol) {
            if (draggedFrom === 'tableau') {
                const { col: sourceCol, index } = draggedCard;
                
                // ê°™ì€ ì»¬ëŸ¼ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê²½ìš° ë¬´ì‹œ
                if (sourceCol === targetCol) return;
                
                const cardsToMove = tableau[sourceCol].slice(index);
                const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;

                if (canPlaceOnTableau(cardsToMove[0], targetCard)) {
                    saveGameState();
                    
                    // ì¹´ë“œ ì´ë™
                    tableau[sourceCol].splice(index);
                    tableau[targetCol].push(...cardsToMove);
                    
                    // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                    if (tableau[sourceCol].length > 0) {
                        const lastCard = tableau[sourceCol][tableau[sourceCol].length - 1];
                        if (!lastCard.faceUp) {
                            lastCard.faceUp = true;
                            score += 5;
                        }
                    }
                    
                    moves++;
                    score += 5;
                    animateScoreIncrease(5);
                    renderGame();
                    checkWin();
                }
            } else if (draggedFrom === 'waste') {
                const card = waste[draggedCard.index];
                const targetCard = tableau[targetCol].length > 0 ? tableau[targetCol][tableau[targetCol].length - 1] : null;

                if (canPlaceOnTableau(card, targetCard)) {
                    saveGameState();
                    waste.pop();
                    tableau[targetCol].push(card);
                    moves++;
                    score += 5;
                    animateScoreIncrease(5);
                    renderGame();
                    checkWin();
                }
            }
        }

        // íŒŒìš´ë°ì´ì…˜ ë“œë¡­ ì²˜ë¦¬
        function handleFoundationDrop(targetSuit) {
            let card = null;
            
            if (draggedFrom === 'tableau') {
                const { col, index } = draggedCard;
                if (index !== tableau[col].length - 1) return; // ë§¨ ìœ„ ì¹´ë“œë§Œ ê°€ëŠ¥
                card = tableau[col][index];
            } else if (draggedFrom === 'waste') {
                card = waste[draggedCard.index];
            }

            if (card && canPlaceOnFoundation(card, targetSuit)) {
                saveGameState();
                
                // ì¹´ë“œ ì´ë™
                if (draggedFrom === 'tableau') {
                    const { col, index } = draggedCard;
                    tableau[col].splice(index, 1);
                    
                    // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                    if (tableau[col].length > 0) {
                        const lastCard = tableau[col][tableau[col].length - 1];
                        if (!lastCard.faceUp) {
                            lastCard.faceUp = true;
                            score += 5;
                        }
                    }
                } else if (draggedFrom === 'waste') {
                    waste.pop();
                }
                
                foundations[targetSuit].push(card);
                moves++;
                score += 10;
                animateScoreIncrease(10);
                renderGame();
                checkWin();
                checkAutoComplete();
            }
        }

        // íƒ€ë¸”ë¡œ ë°°ì¹˜ ê°€ëŠ¥ í™•ì¸
        function canPlaceOnTableau(card, targetCard) {
            if (!targetCard) {
                // ë¹ˆ ì¹¸ì—ëŠ” í‚¹ë§Œ ë†“ì„ ìˆ˜ ìˆìŒ
                return card.rank === 'king';
            }
            // ê¸°ì¡´ ì¹´ë“œ ìœ„ì—ëŠ” ìƒ‰ì´ ë‹¤ë¥´ê³  ê°’ì´ 1 ì‘ì€ ì¹´ë“œë§Œ ê°€ëŠ¥
            return card.color !== targetCard.color && card.value === targetCard.value - 1;
        }

        // íŒŒìš´ë°ì´ì…˜ ë°°ì¹˜ ê°€ëŠ¥ í™•ì¸
        function canPlaceOnFoundation(card, targetSuit) {
            if (card.suit !== targetSuit) return false;
            const foundation = foundations[targetSuit];
            if (foundation.length === 0) return card.value === 1; // ì—ì´ìŠ¤
            return card.value === foundation[foundation.length - 1].value + 1;
        }

        // ì¹´ë“œ í´ë¦­ ì²˜ë¦¬
        function handleCardClick(e) {
            const cardEl = e.target;
            const col = parseInt(cardEl.dataset.column);
            const index = parseInt(cardEl.dataset.index);

            // ìš°í´ë¦­ - ìë™ìœ¼ë¡œ íŒŒìš´ë°ì´ì…˜ì— ì´ë™
            if (e.button === 2) {
                e.preventDefault();
                tryAutoMoveToFoundation(cardEl, col, index);
                return;
            }

            // ë”ë¸”í´ë¦­ - ìë™ìœ¼ë¡œ íŒŒìš´ë°ì´ì…˜ì— ì´ë™
            if (e.detail === 2) {
                tryAutoMoveToFoundation(cardEl, col, index);
                return;
            }

            // ë’¤ì§‘íŒ ì¹´ë“œ í´ë¦­ì‹œ ì•ë©´ìœ¼ë¡œ (ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œëŠ” ì œì™¸)
            if (!isNaN(col) && !isNaN(index) && col !== undefined && index !== undefined && 
                tableau[col] && tableau[col][index] && 
                !tableau[col][index].faceUp && index === tableau[col].length - 1) {
                saveGameState();
                
                // ì¹´ë“œ ë’¤ì§‘ê¸° ì• ë‹ˆë©”ì´ì…˜
                cardEl.classList.add('flipping');
                setTimeout(() => {
                    tableau[col][index].faceUp = true;
                    score += 5;
                    moves++;
                    animateScoreIncrease(5);
                    cardEl.classList.remove('flipping');
                    cardEl.classList.add('flipped');
                    renderGame();
                    setTimeout(() => {
                        cardEl.classList.remove('flipped');
                    }, 300);
                }, 150);
            }
        }
        
        // ìë™ íŒŒìš´ë°ì´ì…˜ ì´ë™ ì‹œë„ (ì•ˆì „ì¥ì¹˜ ì¶”ê°€)
        function tryAutoMoveToFoundation(cardEl, col, index) {
            // ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì´ë©´ ë¬´ì‹œ
            if (isProcessingDoubleClick) {
                return;
            }
            
            let card = null;
            let fromWaste = false;
            
            // ì›¨ì´ìŠ¤íŠ¸ì—ì„œ ì˜¨ ì¹´ë“œì¸ì§€ í™•ì¸
            if (cardEl.classList.contains('waste-card')) {
                if (waste.length > 0) {
                    card = waste[waste.length - 1];
                    fromWaste = true;
                }
            } 
            // íƒ€ë¸”ë¡œì—ì„œ ì˜¨ ì¹´ë“œì¸ì§€ í™•ì¸
            else if (col !== undefined && index !== undefined) {
                if (tableau[col].length > index && index === tableau[col].length - 1) {
                    card = tableau[col][index];
                }
            }
            
            if (!card || !card.faceUp || !card.suit || !card.rank) {
                return;
            }
            
            // íŒŒìš´ë°ì´ì…˜ì— ë†“ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
            const targetSuit = card.suit;
            if (canPlaceOnFoundation(card, targetSuit)) {
                isProcessingDoubleClick = true; // ì²˜ë¦¬ ì‹œì‘
                const targetFoundation = document.querySelector(`.foundation[data-suit="${targetSuit}"]`);
                
                // ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì´ë™
                animateCardMove(cardEl, targetFoundation, () => {
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ ì‹œì ì— ë‹¤ì‹œ í•œ ë²ˆ í™•ì¸
                    let cardStillExists = false;
                    
                    if (fromWaste) {
                        cardStillExists = waste.length > 0 && waste[waste.length - 1] === card;
                    } else {
                        cardStillExists = tableau[col].length > index && tableau[col][index] === card;
                    }
                    
                    if (cardStillExists) {
                        saveGameState();
                        
                        // ì¹´ë“œ ì´ë™
                        if (fromWaste) {
                            waste.pop();
                        } else {
                            tableau[col].splice(index, 1);
                            
                            // ì†ŒìŠ¤ ì»¬ëŸ¼ì˜ ë§ˆì§€ë§‰ ì¹´ë“œ ë’¤ì§‘ê¸°
                            if (tableau[col].length > 0) {
                                const lastCard = tableau[col][tableau[col].length - 1];
                                if (!lastCard.faceUp) {
                                    lastCard.faceUp = true;
                                    score += 5;
                                }
                            }
                        }
                        
                        foundations[targetSuit].push(card);
                        moves++;
                        score += 10;
                        animateScoreIncrease(10);
                        renderGame();
                        checkWin();
                        
                        // ì—°ì† ìë™ ì´ë™ ì²´í¬
                        checkAutoComplete();
                    }
                    
                    isProcessingDoubleClick = false; // ì²˜ë¦¬ ì™„ë£Œ
                });
            }
        }
        
        // ìë™ ì™„ì„± ì²´í¬ (ëª¨ë“  ì¹´ë“œê°€ ì˜¤í”ˆë˜ì—ˆì„ ë•Œ)
        function checkAutoComplete() {
            if (stock.length > 0) return;
            
            let allOpen = true;
            let hasTableauCards = false;
            
            for (let col = 0; col < tableau.length; col++) {
                for (let card of tableau[col]) {
                    hasTableauCards = true;
                    if (!card.faceUp) {
                        allOpen = false;
                        break;
                    }
                }
                if (!allOpen) break;
            }
            
            if (allOpen && (hasTableauCards || waste.length > 0)) {
                autoCompleteGame();
            }
        }
        
        // ìë™ ì™„ì„± ì‹¤í–‰ (ì´ˆê³ ì† ì• ë‹ˆë©”ì´ì…˜)
        function autoCompleteGame() {
            let autoMoveCount = 0;
            const maxAutoMoves = 500;
            
            const ultraFastAutoMove = () => {
                autoMoveCount++;
                if (autoMoveCount > maxAutoMoves) {
                    checkWin();
                    return;
                }
                
                const totalFoundationCards = Object.values(foundations).reduce((sum, pile) => sum + pile.length, 0);
                if (totalFoundationCards === 52) {
                    checkWin();
                    return;
                }
                
                // ì›¨ì´ìŠ¤íŠ¸ì—ì„œ íŒŒìš´ë°ì´ì…˜ìœ¼ë¡œ ì´ë™ ì‹œë„
                if (waste.length > 0) {
                    const wasteCard = waste[waste.length - 1];
                    if (canPlaceOnFoundation(wasteCard, wasteCard.suit)) {
                        // í˜„ì¬ ì›¨ì´ìŠ¤íŠ¸ ì¹´ë“œ ìš”ì†Œ ì°¾ê¸°
                        const wasteCardEl = document.querySelector('#waste .card:last-child');
                        const targetFoundation = document.querySelector(`.foundation[data-suit="${wasteCard.suit}"]`);
                        
                        if (wasteCardEl && targetFoundation) {
                            waste.pop();
                            foundations[wasteCard.suit].push(wasteCard);
                            score += 10;
                            moves++;
                            
                                                            autoCompleteAnimateCardMove(wasteCardEl, targetFoundation, () => {
                                renderGame();
                            });
                            // ì¤‘ë³µ íƒ€ì´ë°ìœ¼ë¡œ ë‹¤ìŒ ì¹´ë“œ ì´ë™ (ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚˜ê¸° ì „ì— ì‹œì‘)
                            setTimeout(ultraFastAutoMove, 80);
                            return;
                        }
                    }
                }
                
                // íƒ€ë¸”ë¡œì—ì„œ íŒŒìš´ë°ì´ì…˜ìœ¼ë¡œ ì´ë™ ì‹œë„
                for (let col = 0; col < tableau.length; col++) {
                    if (tableau[col].length > 0) {
                        const topCard = tableau[col][tableau[col].length - 1];
                        if (topCard.faceUp && canPlaceOnFoundation(topCard, topCard.suit)) {
                            // í˜„ì¬ íƒ€ë¸”ë¡œ ì¹´ë“œ ìš”ì†Œ ì°¾ê¸°
                            const cardEl = document.querySelector(`.column[data-column="${col}"] .card:last-child`);
                            const targetFoundation = document.querySelector(`.foundation[data-suit="${topCard.suit}"]`);
                            
                            if (cardEl && targetFoundation) {
                                tableau[col].pop();
                                
                                if (tableau[col].length > 0) {
                                    const lastCard = tableau[col][tableau[col].length - 1];
                                    if (!lastCard.faceUp) {
                                        lastCard.faceUp = true;
                                        score += 5;
                                    }
                                }
                                
                                foundations[topCard.suit].push(topCard);
                                score += 10;
                                moves++;
                                
                                autoCompleteAnimateCardMove(cardEl, targetFoundation, () => {
                                    renderGame();
                                });
                                // ì¤‘ë³µ íƒ€ì´ë°ìœ¼ë¡œ ë‹¤ìŒ ì¹´ë“œ ì´ë™ (ì• ë‹ˆë©”ì´ì…˜ì´ ëë‚˜ê¸° ì „ì— ì‹œì‘)
                                setTimeout(ultraFastAutoMove, 80);
                                return;
                            }
                        }
                    }
                }
                
                checkWin();
            };
            

            // ë Œë”ë§ ì™„ë£Œ í›„ ìë™ ì™„ì„± ì‹œì‘
            renderGame();
            setTimeout(ultraFastAutoMove, 5);
        }

        // ìŠ¤í†¡ì—ì„œ ì¹´ë“œ ë½‘ê¸° (3ì¥ì”©) - ì¤‘ë³µ ë°©ì§€ ê°œì„ 
        function drawCard() {
            saveGameState();
            
            if (stock.length > 0) {
                drawCount++;
                const cardsToDraw = Math.min(3, stock.length);
                const drawnCards = [];
                
                // ë§ˆì§€ë§‰ 1-2ì¥ì¸ì§€ ì²´í¬
                const isLastFewCards = stock.length <= 2;
                
                for (let i = 0; i < cardsToDraw; i++) {
                    if (stock.length === 0) break;
                    const card = stock.pop();
                    
                    if (!card || !card.suit || !card.rank) {
                        i--;
                        continue;
                    }
                    
                    card.faceUp = true;
                    card.drawId = Date.now() + '_' + i;
                    drawnCards.push(card);
                }
                
                drawnCards.forEach(card => {
                    const alreadyExists = waste.some(w => w.drawId === card.drawId);
                    if (!alreadyExists) {
                        waste.push(card);
                    }
                });
                
                animateCardDraw(drawnCards, isLastFewCards);
                
            } else if (waste.length > 0) {
                const validWasteCards = waste.filter(c => c && c.suit && c.rank);
                const uniqueWasteCards = [];
                const seenCards = new Set();
                
                validWasteCards.forEach(card => {
                    const cardKey = `${card.suit}-${card.rank}`;
                    if (!seenCards.has(cardKey)) {
                        seenCards.add(cardKey);
                        uniqueWasteCards.push(card);
                    }
                });
                
                uniqueWasteCards.forEach(card => {
                    card.faceUp = false;
                    delete card.drawId;
                });
                
                stock = [...uniqueWasteCards].reverse();
                waste = [];
                
                renderGame();
            }
        }



        // ìŠ¹ë¦¬ í™•ì¸
        function checkWin() {
            const totalFoundationCards = Object.values(foundations).reduce((sum, pile) => sum + pile.length, 0);
            if (totalFoundationCards === 52) {
                gameWon = true;
                score += 100; // ë³´ë„ˆìŠ¤ ì ìˆ˜
                playWinAnimation();
                setTimeout(() => showWinModal(), 2000);
            }
        }
        
        // ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜
        function playWinAnimation() {
            // íŒŒìš´ë°ì´ì…˜ì˜ ëª¨ë“  ì¹´ë“œë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ìœ„ë¡œ ì˜¬ë¦¬ê¸°
            const foundationCards = [];
            
            // ê° íŒŒìš´ë°ì´ì…˜ì—ì„œ ì¹´ë“œë“¤ ìˆ˜ì§‘
            Object.keys(foundations).forEach(suit => {
                const foundationEl = document.querySelector(`.foundation[data-suit="${suit}"]`);
                const cards = foundationEl.querySelectorAll('.card');
                cards.forEach(card => foundationCards.push(card));
            });
            
            // ìˆœì°¨ì ìœ¼ë¡œ ìŠ¹ë¦¬ ì• ë‹ˆë©”ì´ì…˜ ì ìš©
            foundationCards.forEach((card, index) => {
                setTimeout(() => {
                    card.classList.add('winning');
                }, index * 50);
            });
            
            // ì ìˆ˜ ì¦ê°€ ì• ë‹ˆë©”ì´ì…˜
            animateScoreIncrease(100);
        }

        // ìŠ¹ë¦¬ ëª¨ë‹¬ í‘œì‹œ
        function showWinModal() {
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTime').textContent = document.getElementById('time').textContent;
            document.getElementById('finalMoves').textContent = moves;
            document.getElementById('winModal').style.display = 'flex';
        }

        // ìŠ¹ë¦¬ ëª¨ë‹¬ ë‹«ê¸°
        function closeWinModal() {
            document.getElementById('winModal').style.display = 'none';
        }

        // ì ìˆ˜ ì—…ë°ì´íŠ¸
        function updateScore() {
            document.getElementById('score').textContent = score;
            document.getElementById('moves').textContent = moves;
        }

        // íƒ€ì´ë¨¸ ì—…ë°ì´íŠ¸
        function updateTimer() {
            if (gameWon) return;
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            document.getElementById('time').textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            setTimeout(updateTimer, 1000);
        }



        // ê²Œì„ ì‹œì‘
        newGame();
    </script>
</body>
</html> 