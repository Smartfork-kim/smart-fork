<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì—ì–´í•˜í‚¤ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }

        .game-container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 20px;
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .score-board {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 50px;
            margin-bottom: 15px;
            font-size: 24px;
            font-weight: bold;
        }

        .player-score { color: #3498db; }
        .ai-score { color: #e74c3c; }

        #gameCanvas {
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }

        .controls {
            text-align: center;
            margin-top: 15px;
        }

        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            margin: 0 10px;
            transition: background 0.3s;
        }

        button:hover { background: #2980b9; }
        button:disabled { background: #bdc3c7; cursor: not-allowed; }

        .instructions {
            text-align: center;
            margin-top: 20px;
            color: white;
            font-size: 14px;
        }

        .game-start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 10px;
            z-index: 10;
        }

        .start-content {
            text-align: center;
            color: white;
            background: rgba(52, 152, 219, 0.9);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .start-content h2 {
            margin: 0 0 20px 0;
            font-size: 28px;
        }

        .start-content p {
            margin: 10px 0;
            font-size: 18px;
        }

        .start-btn-center {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            margin: 20px 0;
            transition: all 0.3s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .start-btn-center:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(0,0,0,0.4);
        }

        .instructions-small {
            font-size: 14px !important;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ğŸ’ ì—ì–´í•˜í‚¤ ê²Œì„ ğŸ’</h1>
            <div class="score-board">
                <div class="player-score">í”Œë ˆì´ì–´: <span id="playerScore">0</span></div>
                <div class="ai-score">ì»´í“¨í„°: <span id="aiScore">0</span></div>
            </div>
        </div>
        
        <div class="canvas-container" style="position: relative; display: inline-block;">
            <canvas id="gameCanvas" width="1100" height="693"></canvas>
            
            <div id="gameStartOverlay" class="game-start-overlay">
                <div class="start-content">
                    <h2>ğŸ’ ì—ì–´í•˜í‚¤ ê²Œì„ ğŸ’</h2>
                    <p>5ì  ë¨¼ì € ë“ì í•˜ë©´ ìŠ¹ë¦¬!</p>
                    <button onclick="startGame()" id="startBtnCenter" class="start-btn-center">ê²Œì„ ì‹œì‘</button>
                    <p class="instructions-small">íŒŒë€ìƒ‰ ë§ë ›ì„ í´ë¦­í•˜ê³  ë“œë˜ê·¸í•˜ì„¸ìš”</p>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="startGame()" id="startBtn" style="display: none;">ê²Œì„ ì‹œì‘</button>
            <button onclick="resetGame()" id="resetBtn">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <div class="instructions">
        <p>ğŸ¯ ëª©í‘œ: 5ì  ë¨¼ì € ë“ì í•˜ë©´ ìŠ¹ë¦¬!</p>
        <p>ğŸ–±ï¸ íŒŒë€ìƒ‰ ë§ë ›ì„ í´ë¦­í•˜ê³  ë“œë˜ê·¸í•˜ì—¬ í½ì„ ìƒëŒ€ë°© ê³¨ëŒ€ì— ë„£ìœ¼ì„¸ìš”</p>
        <p>âš¡ í½ì€ ë²½ê³¼ ë§ë ›ì— ë¶€ë”ªíˆë©´ íŠ•ê²¨ë‚˜ê°‘ë‹ˆë‹¤</p>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ê²Œì„ ìƒíƒœ
        let gameState = 'menu';
        let playerScore = 0;
        let aiScore = 0;
        const maxScore = 5;
        
        // ì´ë¯¸ì§€ ë¡œë”©
        const images = {};
        const imageNames = ['airhockey map', 'airhockey mallet blue', 'airhockey mallet red', 'airhockey puck'];
        let imagesLoaded = 0;
        
        imageNames.forEach(name => {
            images[name] = new Image();
            images[name].onload = () => {
                imagesLoaded++;
                if (name === 'airhockey map') {
                    canvas.width = images[name].width;
                    canvas.height = images[name].height;
                    
                    // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ìœ„ì¹˜ ì¡°ì •
                    player.x = canvas.width * 0.2;
                    player.y = canvas.height * 0.5;
                    ai.x = canvas.width * 0.8;
                    ai.y = canvas.height * 0.5;
                    puck.x = canvas.width * 0.5;
                    puck.y = canvas.height * 0.5;
                    
                    ai.mode = 'defense';
                    ai.attackTarget = { x: 50, y: canvas.height / 2 };
                }
                
                if (imagesLoaded === imageNames.length) {
                    initGame();
                }
            };
            images[name].src = name + '.png';
        });
        
        // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ì •ì˜
        let player = {
            x: 150, y: 300, prevX: 150, prevY: 300,
            vx: 0, vy: 0, radius: 35, speed: 5
        };
        
        let ai = {
            x: 1050, y: 300, prevX: 1050, prevY: 300,
            vx: 0, vy: 0, radius: 35, speed: 6,
            mode: 'defense',
            attackTarget: { x: 0, y: 0 },
            pullbackStartTime: 0,
            cooldownStartTime: 0
        };
        
        let puck = {
            x: 600, y: 300, radius: 22.5,
            vx: 0, vy: 0, maxSpeed: 25,
            trail: []
        };
        
        let mouse = { x: 0, y: 0, isPressed: false };
        
        // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ì²˜ë¦¬
        canvas.addEventListener('mousemove', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouse.x = (e.clientX - rect.left) * scaleX;
            mouse.y = (e.clientY - rect.top) * scaleY;
            
            if (mouse.x < canvas.width / 2 && mouse.isPressed) {
                const clampedX = Math.max(45 + player.radius, Math.min(canvas.width / 2 - player.radius, mouse.x));
                const clampedY = Math.max(39 + player.radius, Math.min(651 - player.radius, mouse.y));
                
                const distance = Math.sqrt((clampedX - player.x) ** 2 + (clampedY - player.y) ** 2);
                const lerpFactor = Math.min(0.9, Math.max(0.3, distance / 80));
                
                player.x += (clampedX - player.x) * lerpFactor;
                player.y += (clampedY - player.y) * lerpFactor;
            }
        });
        
        canvas.addEventListener('mousedown', () => mouse.isPressed = true);
        canvas.addEventListener('mouseup', () => mouse.isPressed = false);
        canvas.addEventListener('mouseleave', () => mouse.isPressed = false);
        canvas.addEventListener('mouseenter', (e) => {
            if (e.buttons === 1) mouse.isPressed = true;
        });
        
        function initGame() {
            resetPositions();
            gameLoop();
        }
        
        function startGame() {
            playerScore = 0;
            aiScore = 0;
            updateScore();
            
            gameState = 'playing';
            document.getElementById('startBtn').disabled = true;
            document.getElementById('gameStartOverlay').style.display = 'none';
            
            resetPositions();
        }
        
        function resetGame() {
            gameState = 'menu';
            playerScore = 0;
            aiScore = 0;
            updateScore();
            resetPositions();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('gameStartOverlay').style.display = 'flex';
            
            document.querySelector('.start-content h2').textContent = 'ğŸ’ ì—ì–´í•˜í‚¤ ê²Œì„ ğŸ’';
            document.querySelector('.start-content p').textContent = '5ì  ë¨¼ì € ë“ì í•˜ë©´ ìŠ¹ë¦¬!';
            document.getElementById('startBtnCenter').textContent = 'ê²Œì„ ì‹œì‘';
        }
        
        function resetPositions() {
            player.x = canvas.width * 0.2;
            player.y = canvas.height * 0.5;
            ai.x = canvas.width * 0.8;
            ai.y = canvas.height * 0.5;
            puck.x = canvas.width * 0.5;
            puck.y = canvas.height * 0.5;
            puck.vx = (Math.random() - 0.5) * 4;
            puck.vy = (Math.random() - 0.5) * 4;
            puck.trail = [];
            
            ai.mode = 'defense';
            ai.attackTarget = { x: 50, y: canvas.height / 2 };
            ai.pullbackStartTime = 0;
            ai.cooldownStartTime = 0;
        }
        
        function updateScore() {
            document.getElementById('playerScore').textContent = playerScore;
            document.getElementById('aiScore').textContent = aiScore;
        }
        
        function checkGoal() {
            // í”Œë ˆì´ì–´ ê³¨ëŒ€ (ì™¼ìª½) - AI ë“ì 
            if (puck.x >= 72 && puck.x <= 125 && puck.y >= 280 && puck.y <= 410) {
                aiScore++;
                updateScore();
                checkWin('AI');
                resetPositions();
                return true;
            }
            
            // AI ê³¨ëŒ€ (ì˜¤ë¥¸ìª½) - í”Œë ˆì´ì–´ ë“ì 
            if (puck.x >= 988 && puck.x <= 1039 && puck.y >= 280 && puck.y <= 410) {
                playerScore++;
                updateScore();
                checkWin('Player');
                resetPositions();
                return true;
            }
            
            return false;
        }
        
        function checkWin(winner) {
            if (playerScore >= maxScore) {
                gameState = 'gameOver';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('gameStartOverlay').style.display = 'flex';
                document.querySelector('.start-content h2').textContent = 'ğŸ‰ í”Œë ˆì´ì–´ ìŠ¹ë¦¬! ğŸ‰';
                document.querySelector('.start-content p').textContent = 'ì¶•í•˜í•©ë‹ˆë‹¤! ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
                document.getElementById('startBtnCenter').textContent = 'ë‹¤ì‹œ ì‹œì‘';
            } else if (aiScore >= maxScore) {
                gameState = 'gameOver';
                document.getElementById('startBtn').disabled = false;
                document.getElementById('gameStartOverlay').style.display = 'flex';
                document.querySelector('.start-content h2').textContent = 'ğŸ’» ì»´í“¨í„° ìŠ¹ë¦¬!';
                document.querySelector('.start-content p').textContent = 'ë‹¤ì‹œ ë„ì „í•´ë³´ì„¸ìš”!';
                document.getElementById('startBtnCenter').textContent = 'ë‹¤ì‹œ ì‹œì‘';
            }
        }
        
        function updatePlayer() {
            player.prevX = player.x;
            player.prevY = player.y;
            
            if (mouse.x < canvas.width / 2 && mouse.isPressed) {
                const targetX = mouse.x;
                const targetY = mouse.y;
                
                const distance = Math.sqrt((targetX - player.x) ** 2 + (targetY - player.y) ** 2);
                const lerpFactor = Math.min(0.8, Math.max(0.2, distance / 100));
                
                player.x += (targetX - player.x) * lerpFactor;
                player.y += (targetY - player.y) * lerpFactor;
            }
            
            player.x = Math.max(45 + player.radius, Math.min(canvas.width / 2 - player.radius, player.x));
            player.y = Math.max(39 + player.radius, Math.min(651 - player.radius, player.y));
            
            player.vx = player.x - player.prevX;
            player.vy = player.y - player.prevY;
            
            const playerSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
            if (playerSpeed > 20) {
                player.vx = (player.vx / playerSpeed) * 20;
                player.vy = (player.vy / playerSpeed) * 20;
            }
        }
        
        function updateAI() {
            if (gameState !== 'playing') return;
            
            ai.prevX = ai.x;
            ai.prevY = ai.y;
            
            const distanceToPuck = Math.sqrt((puck.x - ai.x) ** 2 + (puck.y - ai.y) ** 2);
            const playerGoalX = 50;
            const playerGoalY = canvas.height / 2;
            const puckSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
            
            const toGoalDx = playerGoalX - puck.x;
            const toGoalDy = playerGoalY - puck.y;
            const goalAngle = Math.atan2(toGoalDy, toGoalDx);
            const isGoodAttackAngle = toGoalDx < 0;
            
            if (ai.mode === 'defense') {
                if (puck.x > canvas.width * 0.5) {
                    ai.mode = 'approach';
                }
                
                const defenseX = canvas.width * 0.8;
                const defenseY = canvas.height * 0.5;
                
                const dx = defenseX - ai.x;
                const dy = defenseY - ai.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    ai.x += (dx / distance) * ai.speed * 0.8;
                    ai.y += (dy / distance) * ai.speed * 0.8;
                }
                
            } else if (ai.mode === 'approach') {
                const approachThreshold = puckSpeed > 15 ? 120 : puckSpeed > 10 ? 100 : 80;
                
                if (distanceToPuck < approachThreshold) {
                    ai.mode = 'pullback';
                    ai.pullbackStartTime = Date.now();
                }
                
                const approachDistance = puckSpeed > 15 ? 80 : 60;
                let targetX, targetY;
                
                if (isGoodAttackAngle) {
                    targetX = puck.x - Math.cos(goalAngle) * approachDistance;
                    targetY = puck.y - Math.sin(goalAngle) * approachDistance;
                } else {
                    const sideAngle = puck.y > canvas.height / 2 ? -Math.PI/2 : Math.PI/2;
                    targetX = puck.x - Math.cos(sideAngle) * approachDistance;
                    targetY = puck.y - Math.sin(sideAngle) * approachDistance;
                }
                
                targetX = Math.max(canvas.width * 0.5 + ai.radius, targetX);
                
                const dx = targetX - ai.x;
                const dy = targetY - ai.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    const approachSpeed = puckSpeed > 15 ? 1.8 : 1.4;
                    ai.x += (dx / distance) * ai.speed * approachSpeed;
                    ai.y += (dy / distance) * ai.speed * approachSpeed;
                }
                
            } else if (ai.mode === 'pullback') {
                const pullbackTime = Date.now() - ai.pullbackStartTime;
                const waitTime = puckSpeed > 15 ? 150 : puckSpeed > 10 ? 200 : 250;
                
                if (pullbackTime > waitTime) {
                    ai.mode = 'attack';
                    
                    if (isGoodAttackAngle) {
                        ai.attackTarget.x = playerGoalX;
                        ai.attackTarget.y = playerGoalY;
                    } else {
                        if (puck.y > canvas.height / 2) {
                            ai.attackTarget.x = puck.x;
                            ai.attackTarget.y = 39 + 50;
                        } else {
                            ai.attackTarget.x = puck.x;
                            ai.attackTarget.y = 651 - 50;
                        }
                    }
                }
                
                const pullbackDistance = puckSpeed > 15 ? 40 : 30;
                let pullbackX, pullbackY;
                
                if (isGoodAttackAngle) {
                    pullbackX = puck.x - Math.cos(goalAngle) * pullbackDistance;
                    pullbackY = puck.y - Math.sin(goalAngle) * pullbackDistance;
                } else {
                    const sideAngle = puck.y > canvas.height / 2 ? -Math.PI/2 : Math.PI/2;
                    pullbackX = puck.x - Math.cos(sideAngle) * pullbackDistance;
                    pullbackY = puck.y - Math.sin(sideAngle) * pullbackDistance;
                }
                
                pullbackX = Math.max(canvas.width * 0.5 + ai.radius, pullbackX);
                
                const dx = pullbackX - ai.x;
                const dy = pullbackY - ai.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 3) {
                    const pullbackSpeed = puckSpeed > 15 ? 2.0 : 1.5;
                    ai.x += (dx / distance) * ai.speed * pullbackSpeed;
                    ai.y += (dy / distance) * ai.speed * pullbackSpeed;
                }
                
            } else if (ai.mode === 'attack') {
                const puckDx = puck.x - ai.x;
                const puckDy = puck.y - ai.y;
                const puckDistance = Math.sqrt(puckDx * puckDx + puckDy * puckDy);
                
                if (puckDistance > ai.radius + puck.radius + 5) {
                    const attackSpeed = puckSpeed > 15 ? 3.0 : puckSpeed > 10 ? 2.5 : 2.0;
                    ai.x += (puckDx / puckDistance) * ai.speed * attackSpeed;
                    ai.y += (puckDy / puckDistance) * ai.speed * attackSpeed;
                } else {
                    ai.mode = 'cooldown';
                    ai.cooldownStartTime = Date.now();
                }
            } else if (ai.mode === 'cooldown') {
                const cooldownTime = Date.now() - ai.cooldownStartTime;
                const cooldownDuration = puckSpeed > 15 ? 300 : puckSpeed > 10 ? 350 : 400;
                
                if (cooldownTime > cooldownDuration) {
                    // ì¿¨ë‹¤ìš´ì´ ëë‚˜ë©´ ë°”ë¡œ approach ëª¨ë“œë¡œ ì „í™˜í•˜ì—¬ ë” ìì—°ìŠ¤ëŸ½ê²Œ ë™ì‘
                    if (puck.x > canvas.width * 0.5) {
                        ai.mode = 'approach';
                    } else {
                        ai.mode = 'defense';
                    }
                }
                
                // ì¿¨ë‹¤ìš´ ì¤‘ì—ëŠ” ìê¸° ì§„ì˜ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
                const centerX = canvas.width * 0.8; // AI ì§„ì˜ ì¤‘ì•™
                const centerY = canvas.height * 0.5;
                
                const dx = centerX - ai.x;
                const dy = centerY - ai.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ëª©í‘œ ìœ„ì¹˜ì— ë” ê°€ê¹Œì´ ìˆì„ ë•ŒëŠ” ë” ì •í™•í•œ ì •ì§€
                if (distance > 10) {
                    ai.x += (dx / distance) * ai.speed * 1.8;
                    ai.y += (dy / distance) * ai.speed * 1.8;
                } else if (distance > 3) {
                    // ê°€ê¹Œì´ ìˆì„ ë•ŒëŠ” ë” ë¶€ë“œëŸ½ê²Œ
                    ai.x += (dx / distance) * ai.speed * 0.8;
                    ai.y += (dy / distance) * ai.speed * 0.8;
                } else {
                    // ëª©í‘œ ìœ„ì¹˜ì— ë„ë‹¬í–ˆìœ¼ë©´ ì •í™•íˆ ìœ„ì¹˜ ê³ ì •
                    ai.x = centerX;
                    ai.y = centerY;
                }
            }
            
            if ((puck.x < canvas.width * 0.5 || distanceToPuck > 400) && ai.mode !== 'cooldown') {
                ai.mode = 'defense';
            }
            
            ai.x = Math.max(canvas.width / 2 + ai.radius, Math.min(1060 - ai.radius, ai.x));
            ai.y = Math.max(39 + ai.radius, Math.min(651 - ai.radius, ai.y));
            
            ai.vx = ai.x - ai.prevX;
            ai.vy = ai.y - ai.prevY;
            
            const aiSpeed = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
            if (aiSpeed > 15) {
                ai.vx = (ai.vx / aiSpeed) * 15;
                ai.vy = (ai.vy / aiSpeed) * 15;
            }
            

        }
        
        function updatePuck() {
            if (gameState !== 'playing') return;
            
            puck.x += puck.vx;
            puck.y += puck.vy;
            
            const puckSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
            
            if (puckSpeed > 3) {
                puck.trail.push({ x: puck.x, y: puck.y, speed: puckSpeed });
                
                const maxTrailLength = puckSpeed > 15 ? 8 : puckSpeed > 10 ? 6 : puckSpeed > 5 ? 3 : 1;
                if (puck.trail.length > maxTrailLength) {
                    puck.trail.shift();
                }
            } else {
                puck.trail = [];
            }
            
            // í…Œë‘ë¦¬ ì¶©ëŒ ì²˜ë¦¬ (ì—ë„ˆì§€ ì†ì‹¤ í¬í•¨)
            if (puck.y - puck.radius <= 39) {
                puck.vy = -puck.vy * 0.95;
                puck.y = 39 + puck.radius;
            }
            if (puck.y + puck.radius >= 651) {
                puck.vy = -puck.vy * 0.95;
                puck.y = 651 - puck.radius;
            }
            
            // ì¢Œìš° í…Œë‘ë¦¬ ì¶©ëŒ (ê³¨ëŒ€ ì˜ì—­ ì œì™¸)
            if (puck.x - puck.radius <= 45) {
                if (puck.y < 280 || puck.y > 410) {
                    puck.vx = -puck.vx * 0.95;
                    puck.x = 45 + puck.radius;
                }
            }
            if (puck.x + puck.radius >= 1060) {
                if (puck.y < 280 || puck.y > 410) {
                    puck.vx = -puck.vx * 0.95;
                    puck.x = 1060 - puck.radius;
                }
            }
            
            // ê²½ê³„ ë²—ì–´ë‚¨ ë°©ì§€ (ê°•ì œ ë³´ì •)
            if (puck.x < 45) puck.x = 45 + puck.radius;
            if (puck.x > 1060) puck.x = 1060 - puck.radius;
            if (puck.y < 39) puck.y = 39 + puck.radius;
            if (puck.y > 651) puck.y = 651 - puck.radius;
            
            // ê³¨ëŒ€ ë’¤ìª½ ì˜ì—­ ì¶”ê°€ ì¶©ëŒ ì²˜ë¦¬
            if (puck.x < 45 && puck.y > 410) {
                if (puck.x < 45) {
                    puck.vx = -puck.vx * 0.95;
                    puck.x = 45 + puck.radius;
                }
                if (puck.y > 651) {
                    puck.vy = -puck.vy * 0.95;
                    puck.y = 651 - puck.radius;
                }
            }
            
            checkPuckCollision(player);
            checkPuckCollision(ai);
            
            puck.vx *= 0.99;
            puck.vy *= 0.99;
            
            const speed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
            if (speed > puck.maxSpeed) {
                puck.vx = (puck.vx / speed) * puck.maxSpeed;
                puck.vy = (puck.vy / speed) * puck.maxSpeed;
            }
            
            checkGoal();
        }
        
        function checkPuckCollision(mallet) {
            const dx = puck.x - mallet.x;
            const dy = puck.y - mallet.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            const malletSpeed = Math.sqrt(mallet.vx * mallet.vx + mallet.vy * mallet.vy);
            let extendedRadius;
            if (mallet === ai) {
                extendedRadius = puck.radius + mallet.radius + Math.min(malletSpeed * 0.5, 3);
            } else {
                extendedRadius = puck.radius + mallet.radius + Math.max(malletSpeed * 2.0, malletSpeed * 1.0);
            }
            
            if (distance < extendedRadius) {
                const angle = Math.atan2(dy, dx);
                
                if (mallet === ai) {
                    if (ai.mode !== 'cooldown') {
                        ai.mode = 'cooldown';
                        ai.cooldownStartTime = Date.now();
                    }
                }
                
                const targetX = mallet.x + Math.cos(angle) * (mallet.radius + puck.radius);
                const targetY = mallet.y + Math.sin(angle) * (mallet.radius + puck.radius);
                
                puck.x = targetX;
                puck.y = targetY;
                
                let basePower = 3;
                let speedMultiplier = 4;
                let totalPower = basePower + (malletSpeed * speedMultiplier);
                
                if (malletSpeed > 10) {
                    totalPower += 3;
                } else if (malletSpeed > 6) {
                    totalPower += 2;
                } else if (malletSpeed > 3) {
                    totalPower += 1;
                }
                
                const angleDegrees = Math.abs(angle * 180 / Math.PI);
                if (angleDegrees < 15) {
                    totalPower += 2;
                } else if (angleDegrees < 45) {
                    totalPower += 1;
                } else if (angleDegrees > 135) {
                    totalPower -= 1;
                }
                
                totalPower = Math.min(totalPower, 25);
                
                if (mallet === ai && (ai.mode === 'attack' || ai.mode === 'pullback')) {
                    if (ai.mode === 'attack') {
                        totalPower = Math.min(totalPower * 1.8, 25);
                        
                        // AIê°€ ìê¸° ê³¨ëŒ€ ìª½ìœ¼ë¡œ ì¹˜ëŠ” ê²ƒì„ ë°©ì§€
                        const aiGoalX = 1013.5; // AI ê³¨ëŒ€ ì¤‘ì•™ X ì¢Œí‘œ (988~1039ì˜ ì¤‘ì•™)
                        const aiGoalY = 345;    // AI ê³¨ëŒ€ ì¤‘ì•™ Y ì¢Œí‘œ (280~410ì˜ ì¤‘ì•™)
                        
                        // í½ì—ì„œ AI ê³¨ëŒ€ê¹Œì§€ì˜ ë°©í–¥ ë²¡í„°
                        const toAiGoalDx = aiGoalX - puck.x;
                        const toAiGoalDy = aiGoalY - puck.y;
                        const toAiGoalDistance = Math.sqrt(toAiGoalDx * toAiGoalDx + toAiGoalDy * toAiGoalDy);
                        
                        // í˜„ì¬ ì¶©ëŒ ë°©í–¥ê³¼ AI ê³¨ëŒ€ ë°©í–¥ì˜ ê°ë„ ì°¨ì´ ê³„ì‚°
                        const currentAngle = Math.atan2(dy, dx);
                        const toAiGoalAngle = Math.atan2(toAiGoalDy, toAiGoalDx);
                        let angleDiff = Math.abs(currentAngle - toAiGoalAngle);
                        
                        // ê°ë„ ì°¨ì´ë¥¼ 0~Ï€ ë²”ìœ„ë¡œ ì •ê·œí™”
                        if (angleDiff > Math.PI) {
                            angleDiff = 2 * Math.PI - angleDiff;
                        }
                        
                        // AI ê³¨ëŒ€ ìª½ìœ¼ë¡œ ì¹˜ëŠ” ê²½ìš° (ê°ë„ ì°¨ì´ê°€ 60ë„ ì´ë‚´)
                        if (angleDiff < Math.PI / 3) {
                            // ìˆ˜ì§ ë°©í–¥ìœ¼ë¡œ í˜ì„ ì¡°ì •í•˜ì—¬ ê³¨ëŒ€ ìª½ìœ¼ë¡œ ê°€ì§€ ì•Šë„ë¡ í•¨
                            const safeAngle = puck.y > aiGoalY ? -Math.PI/2 : Math.PI/2;
                            const adjustedAngle = safeAngle + (Math.random() - 0.5) * 0.5; // ì•½ê°„ì˜ ëœë¤ì„± ì¶”ê°€
                            
                            puck.vx = Math.cos(adjustedAngle) * totalPower;
                            puck.vy = Math.sin(adjustedAngle) * totalPower;
                            return;
                        }
                    } else {
                        totalPower = Math.min(totalPower * 1.2, 20);
                    }
                    
                    const targetAngle = Math.atan2(ai.attackTarget.y - puck.y, ai.attackTarget.x - puck.x);
                    const adjustedAngle = angle * 0.7 + targetAngle * 0.3;
                    
                    puck.vx = Math.cos(adjustedAngle) * totalPower;
                    puck.vy = Math.sin(adjustedAngle) * totalPower;
                } else {
                    const malletAngle = Math.atan2(mallet.vy, mallet.vx);
                    const speedRatio = Math.min(malletSpeed / 5, 1);
                    const finalAngle = angle * (1 - speedRatio * 0.4) + malletAngle * speedRatio * 0.4;
                    
                    puck.vx = Math.cos(finalAngle) * totalPower;
                    puck.vy = Math.sin(finalAngle) * totalPower;
                }
            }
        }
        
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (images['airhockey map']) {
                ctx.drawImage(images['airhockey map'], 0, 0, canvas.width, canvas.height);
            }
            
            if (images['airhockey mallet blue']) {
                ctx.drawImage(images['airhockey mallet blue'], 
                    player.x - player.radius, player.y - player.radius, 
                    player.radius * 2, player.radius * 2);
            }
            
            if (images['airhockey mallet red']) {
                ctx.drawImage(images['airhockey mallet red'], 
                    ai.x - ai.radius, ai.y - ai.radius, 
                    ai.radius * 2, ai.radius * 2);
            }
            
            if (puck.trail.length > 0 && images['airhockey puck']) {
                const currentPuckSpeed = Math.sqrt(puck.vx * puck.vx + puck.vy * puck.vy);
                
                for (let i = 0; i < puck.trail.length; i++) {
                    const trailPoint = puck.trail[i];
                    
                    let baseAlpha;
                    if (currentPuckSpeed > 15) {
                        baseAlpha = 0.4;
                    } else if (currentPuckSpeed > 10) {
                        baseAlpha = 0.3;
                    } else {
                        baseAlpha = 0.15;
                    }
                    
                    const alpha = (i + 1) / puck.trail.length * baseAlpha;
                    const scale = 0.8 + (i / puck.trail.length) * 0.2;
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.drawImage(images['airhockey puck'], 
                        trailPoint.x - puck.radius * scale, 
                        trailPoint.y - puck.radius * scale, 
                        puck.radius * 2 * scale, 
                        puck.radius * 2 * scale);
                    ctx.restore();
                }
            }
            
            if (images['airhockey puck']) {
                ctx.drawImage(images['airhockey puck'], 
                    puck.x - puck.radius, puck.y - puck.radius, 
                    puck.radius * 2, puck.radius * 2);
            }
        }
        
        function gameLoop() {
            updatePlayer();
            updateAI();
            updatePuck();
            render();
            requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html> 