<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì›ì¹´ë“œ - ì›¹ê²Œì„ ëª¨ìŒ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
                body {
            font-family: 'Noto Sans KR', sans-serif;
            background: #1a1a1a; /* ê²€ì •ê³„ì—´ ë°°ê²½ */
            height: 100vh;
            width: 100vw;
            color: white;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            max-height: 100vh;
            max-width: 100vw;
        }
        

        
        html { 
            overflow: auto;
            font-size: calc((100vh - 40px) / 90.5); /* ê²Œì„ ì»¨í…Œì´ë„ˆ ë†’ì´ì˜ 1% = 1rem */
        }
        
        .back-btn {
            position: fixed;
            top: 2rem;
            left: 2rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            padding: 1.2rem 1.8rem;
            border-radius: 1.2rem;
            cursor: pointer;
            text-decoration: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            font-size: 1.4rem;
            min-width: 10rem;
            height: 4.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
                .game-container {
            height: calc(100vh - 40px);
            width: calc((100vh - 40px) * (1880 / 905));
            display: grid;
            grid-template-areas:
                ". north ."
                "west center east"
                ". . .";
            grid-template-columns: 25% 1fr 25%;
            grid-template-rows: 15% 1fr 20%;
            gap: 10px;
            padding: 20px;
            box-sizing: border-box;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            overflow: hidden;
            background: linear-gradient(135deg, #0F4C3A 0%, #2C5F2D 50%, #0F4C3A 100%);
            border-radius: 15px;
        }
        
        /* í”Œë ˆì´ì–´ ë°°ì¹˜: ë™ì„œë‚¨ë¶ */
        .player-north {
            grid-area: north;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            overflow: visible;
            padding: 10px;
        }
        
        
        .player-west {
            grid-area: west;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: rotate(90deg);
            width: 100%;
            height: 100%;
            overflow: visible;
            padding: 0;
        }
        
        .player-east {
            grid-area: east;
            display: flex;
            justify-content: center;
            align-items: center;
            transform: rotate(-90deg);
            width: 100%;
            height: 100%;
            overflow: visible;
            padding: 0;
        }
        
        .center-area {
            grid-area: center;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6rem;
            position: relative;
        }
        
        /* AI ì¹´ë“œ ì»¨í…Œì´ë„ˆ */
        .player-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        /* ì„œìª½ê³¼ ë™ìª½ ë´‡ ì»¨í…Œì´ë„ˆ íŠ¹ë³„ ì„¤ì • */
        .player-west .player-container,
        .player-east .player-container {
            width: 15rem;
            height: 36rem;
            max-width: 150px;
            max-height: 360px;
            margin: 0 auto;
        }
        
        /* í”Œë ˆì´ì–´ ì»¨í…Œì´ë„ˆëŠ” ì˜ˆì™¸ */
        .player-south .player-container {
            height: 100%;
            width: 100%;
            position: relative;
            overflow: visible;
        }
        
        /* AI ì¹´ë“œ ìŠ¤íƒ€ì¼ */
        .cards-hand {
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            width: 100%;
            height: 15rem;
            max-height: 150px;
            overflow-x: auto;
            overflow-y: visible;
            padding: 1.5rem;
            box-sizing: border-box;
        }
        
        /* í”Œë ˆì´ì–´ ì¹´ë“œ ì˜ì—­ì€ ì˜ˆì™¸ */
        .player-south .cards-hand {
            justify-content: center;
            height: 15rem;
            max-height: 150px;
            overflow: visible;
            padding: 0;
        }
        
        /* ë¶ìª½ ë´‡ ì¹´ë“œ ì˜ì—­ (ì •í™•í•œ ê³„ì‚°: ì¹´ë“œ 7ì¥ ê°€ë¡œ ë°°ì¹˜) */
        .player-north .cards-hand {
            width: 60rem;
            max-width: 600px;
            height: 15rem;
            max-height: 150px;
            overflow: visible;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
        }
        
        /* ì„œìª½ê³¼ ë™ìª½ ë´‡ ì¹´ë“œ ì˜ì—­ (ì •í™•í•œ ê³„ì‚°: ì¹´ë“œ 7ì¥ ë°°ì¹˜ìš©) */
        .player-west .cards-hand,
        .player-east .cards-hand {
            height: 36rem;
            max-height: 360px;
            width: 15rem;
            max-width: 150px;
            overflow: visible;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        

        
        /* í”Œë ˆì´ì–´ ì¹´ë“œ (ì‹¤ì œ ì¹´ë“œìš©ìœ¼ë¡œ ì¡°ì •) */
        .player-south {
            position: absolute !important;
            bottom: 0 !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            width: calc(100% - 40px) !important;
            height: 28rem !important;
            max-height: 280px !important;
            z-index: 99999 !important;
            display: block !important;
            overflow: hidden !important;
            pointer-events: none !important;
        }
        
        .player-south .player-container {
            pointer-events: auto !important;
        }
        
        .player-south .cards-hand {
            position: absolute;
            bottom: -8rem;
            left: 50%;
            transform: translateX(-50%);
            height: 28rem;
            max-height: 280px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
        }
        
        .player-south .card {
            height: 22rem;
            width: 14rem;
            max-height: 240px;
            max-width: 150px;
            margin-left: -2.5rem;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            z-index: 1;
            flex-shrink: 0;
        }

        .player-south .card img {
            height: 100%;
            width: auto;
            object-fit: contain;
            border-radius: 1rem;
        }
        
        .player-south .card:first-child {
            margin-left: 0;
        }
        
        .ai-card:first-child {
            margin-left: 0;
        }
        
        .player-south .card:hover {
            transform: translateY(-5rem);
            z-index: 10000;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
        }
        
        .player-south .card.playable {
            transform: translateY(-1.5rem);
            filter: drop-shadow(0 0 15px rgba(39, 174, 96, 0.9));
        }
        
        .player-south .card.playable:hover {
            transform: translateY(-6.5rem);
        }
        
        /* í”Œë ˆì´ì–´ ì¹´ë“œ í´ë¦­ í›„ ìˆ¨ê¹€ ì²˜ë¦¬ */
        .player-south .card.played {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        /* AI ì¹´ë“œ (ë’·ë©´) */
        .ai-card {
            height: 13rem;
            width: 9rem;
            max-height: 140px;
            max-width: 100px;
            margin-left: -1.8rem;
            border: none;
            background: transparent;
            position: relative;
            z-index: 1;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            flex-shrink: 0;
        }

        .ai-card img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        .ai-card:first-child {
            margin-left: 0;
        }
        
        /* ë´‡ ìƒíƒœ í‘œì‹œ */
        .player-container {
            transition: all 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
        
        .player-container.inactive {
            opacity: 0.4;
            filter: brightness(0.5) saturate(0.5);
        }
        
        .player-container.active {
            opacity: 1;
            filter: brightness(1) saturate(1);
        }
        
        .player-container.inactive .ai-card {
            filter: drop-shadow(0 0 10px rgba(0, 0, 0, 0.7));
        }
        
        /* ì¤‘ì•™ ì˜ì—­ ì¹´ë“œë“¤ (ë” í° í™•ëŒ€) */
        .deck {
            height: 23rem;
            max-height: 250px;
            background: transparent;
            border: none;
            cursor: pointer;
            transition: transform 0.25s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .deck img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        .deck:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
        }
        
        .open-deck {
            height: 23rem;
            max-height: 250px;
            border: none;
            background: transparent;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .open-deck img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        /* ë± ì¹´ìš´íŠ¸ í‘œì‹œ */
        .deck-count {
            position: absolute;
            bottom: -4.5rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 0.8rem 1.5rem;
            border-radius: 2rem;
            font-size: 1.4rem;
            font-weight: bold;
            white-space: nowrap;
            box-shadow: 0 0.4rem 1.5rem rgba(0, 0, 0, 0.3);
        }
        
        /* ì›ì¹´ë“œ ë²„íŠ¼ */
        .onecard-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #E74C3C, #C0392B);
            color: white;
            border: none;
            padding: 3rem 6rem;
            border-radius: 30px;
            font-size: 3rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 20px 50px rgba(231, 76, 60, 0.6);
            z-index: 1000;
            display: none;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        

        

        

        
        /* ë¬´ëŠ¬ ì„ íƒê¸° */
        .suit-selector {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            z-index: 2000;
            display: none;
        }
        
        .suit-options {
            display: flex;
            gap: 25px;
            justify-content: center;
        }
        
        .suit-option {
            width: 100px;
            height: 100px;
            border: 3px solid white;
            border-radius: 15px;
            background: white;
            color: black;
            font-size: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .suit-option:hover {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 255, 255, 0.6);
        }
        
        /* ë””ë²„ê·¸ ëª¨ë“œ */
        .debug-panel {
            position: fixed;
            top: 2rem;
            right: 2rem;
            z-index: 9999999;
            display: flex;
        }
        
        .debug-btn {
            background: rgba(155, 89, 182, 0.9);
            color: white;
            border: none;
            padding: 1.2rem 1.8rem;
            border-radius: 1.2rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            font-weight: bold;
            font-size: 1.4rem;
            min-width: 10rem;
            height: 4.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 9999999;
            position: relative;
        }
        
        .debug-btn:hover {
            background: rgba(155, 89, 182, 1);
            transform: scale(1.05);
            cursor: pointer;
        }
        
        /* ë°˜ì‘í˜• ë””ìì¸ - í™”ë©´ í¬ê¸°ì— ë”°ë¥¸ ë™ì  ìŠ¤ì¼€ì¼ë§ */
        /* CSS calc() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤ì‹œê°„ ë¹„ë¡€ ìŠ¤ì¼€ì¼ë§ */
        /* 1920pxì„ ê¸°ì¤€ìœ¼ë¡œ í™”ë©´ ë„ˆë¹„ì— ë”°ë¼ ë¹„ë¡€ì ìœ¼ë¡œ ìŠ¤ì¼€ì¼ë§ */
        
        .card-selector {
            display: none;
            position: fixed;
            top: 5%;
            left: 5%;
            width: 90%;
            height: 90%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            border-radius: 20px;
            padding: 30px;
            overflow-y: auto;
        }
        
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 15px;
            margin-top: 30px;
        }
        
        .selectable-card {
            width: 80px;
            height: 115px;
            background: white;
            color: black;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            background-size: cover;
            background-position: center;
        }
        
        /* ì• ë‹ˆë©”ì´ì…˜ */
        .card-animation {
            position: fixed;
            height: 24rem;
            border: none;
            background: transparent;
            z-index: 1500;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-animation img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        .card-back-animation {
            position: fixed;
            height: 13rem;
            border: none;
            z-index: 1500;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-back-animation img {
            height: 100%;
            width: auto;
            object-fit: contain;
        }
        
        @keyframes flyToCenter {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--target-x), var(--target-y)) scale(0.9);
                opacity: 1;
            }
        }
        
        @keyframes flyToPlayer {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--target-x), var(--target-y)) scale(1);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
        <div class="game-container">
        <a href="../../index.html" class="back-btn">â† ë©”ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
        
        <!-- ë¶ìª½: AI Bot 2 -->
            <div class="player-north">
                <div class="player-container" id="player-2">
                    <div class="cards-hand" id="cards-2"></div>
                </div>
            </div>
            
            <!-- ì„œìª½: AI Bot 1 -->
            <div class="player-west">
                <div class="player-container" id="player-1">
                    <div class="cards-hand" id="cards-1"></div>
                </div>
            </div>
            
            <!-- ì¤‘ì•™ ì˜ì—­ -->
            <div class="center-area">
                <div class="deck" id="deck" onclick="drawCard()">
                    <img src="../solitaire/cards/back.png" alt="ì¹´ë“œ ë±">
                    <div class="deck-count" id="deck-count">33ì¥</div>
                </div>
                <div class="open-deck" id="open-deck"></div>

                
                <!-- ì›ì¹´ë“œ ë²„íŠ¼ -->
                <button class="onecard-button" id="onecard-button" onclick="onecardCall()">
                    ì›ì¹´ë“œ!
                </button>
            </div>
            
            <!-- ë™ìª½: AI Bot 3 -->
            <div class="player-east">
                <div class="player-container" id="player-3">
                    <div class="cards-hand" id="cards-3"></div>
                </div>
            </div>
            
            <!-- ë””ë²„ê·¸ íŒ¨ë„ -->
            <div class="debug-panel">
                <button class="debug-btn" onclick="startNewGame()">ìƒˆ ê²Œì„</button>
            </div>
            
            <!-- í”Œë ˆì´ì–´ (í™”ë©´ í•˜ë‹¨ ê³ ì •) -->
            <div class="player-south" id="player-south-main">
                <div class="player-container" id="player-0">
                    <div class="cards-hand" id="cards-0"></div>
                </div>
            </div>
            
            <!-- ë¬´ëŠ¬ ì„ íƒê¸° -->
            <div class="suit-selector" id="suit-selector">
                <h2 style="text-align: center; margin-bottom: 20px; color: white;">ë¬´ëŠ¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</h2>
                <div class="suit-options">
                    <div class="suit-option" onclick="selectSuit('â™ ï¸')">â™ ï¸</div>
                    <div class="suit-option" onclick="selectSuit('â™¥ï¸')" style="color: red;">â™¥ï¸</div>
                    <div class="suit-option" onclick="selectSuit('â™¦ï¸')" style="color: red;">â™¦ï¸</div>
                    <div class="suit-option" onclick="selectSuit('â™£ï¸')">â™£ï¸</div>
                </div>
            </div>
            
            <!-- ì¹´ë“œ ì„ íƒê¸° -->
            <div class="card-selector" id="card-selector">
                <h2 style="text-align: center; margin-bottom: 20px;">ì¹´ë“œ ì„ íƒ (ë””ë²„ê·¸ ëª¨ë“œ)</h2>
                <button style="position: absolute; top: 10px; right: 10px; background: #E74C3C; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;" onclick="hideCardSelector()">ë‹«ê¸°</button>
                <div class="card-grid" id="card-grid">
                    <!-- ëª¨ë“  ì¹´ë“œë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ìƒì„±ë¨ -->
                </div>
            </div>
        </div>
    
    <script>
        // ê²Œì„ ë³€ìˆ˜ë“¤
        let gameState = {
            players: [
                { id: 0, name: "í”Œë ˆì´ì–´", hand: [], isAI: false },
                { id: 1, name: "AI Bot 1", hand: [], isAI: true },
                { id: 2, name: "AI Bot 2", hand: [], isAI: true },
                { id: 3, name: "AI Bot 3", hand: [], isAI: true }
            ],
            currentPlayer: 0,
            direction: 1, // 1: ì‹œê³„ë°©í–¥, -1: ë°˜ì‹œê³„ë°©í–¥
            deck: [],
            openDeck: [],
            currentSuit: 'â™ ï¸',
            currentRank: '7',
            attackStack: [], // ê³µê²© ì¹´ë“œë“¤ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
            onecardButtonActive: false,
            onecardTimer: null,
            waitingForSuitSelection: false,
            suitSelectionPlayerIndex: -1,
            aiProcessing: false // AI ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ í”Œë˜ê·¸
        };
        
        // ì¹´ë“œ ìƒì„± í•¨ìˆ˜ë“¤
        function createDeck() {
            const suits = ['â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸'];
            const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const deck = [];
            
            // ì¼ë°˜ ì¹´ë“œ 52ì¥
            for (let suit of suits) {
                for (let rank of ranks) {
                    deck.push({ suit, rank, type: 'normal' });
                }
            }
            
            // ì¡°ì»¤ 2ì¥
            deck.push({ suit: 'ğŸƒ', rank: 'Blue', type: 'joker', color: 'blue' });
            deck.push({ suit: 'ğŸƒ', rank: 'Red', type: 'joker', color: 'red' });
            
            return deck;
        }
        
        function shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }
        
        // ê²Œì„ ì´ˆê¸°í™”
        function initGame() {
            gameState.deck = shuffleDeck(createDeck());
            gameState.openDeck = [];
            
            // ê° í”Œë ˆì´ì–´ì—ê²Œ 7ì¥ì”© ë¶„ë°°
            for (let player of gameState.players) {
                player.hand = [];
                for (let i = 0; i < 7; i++) {
                    if (gameState.deck.length > 0) {
                        player.hand.push(gameState.deck.pop());
                    }
                }
            }
            
            // ì²« ë²ˆì§¸ ì˜¤í”ˆ ì¹´ë“œ
            let firstCard;
            if (gameState.deck.length > 0) {
                firstCard = gameState.deck.pop();
                gameState.openDeck = [firstCard];
                gameState.currentSuit = firstCard.suit;
                gameState.currentRank = firstCard.rank;
                
                // ì²« ì¹´ë“œê°€ íŠ¹ìˆ˜ ì¹´ë“œì¸ ê²½ìš° íš¨ê³¼ ì ìš©
                applyFirstCardEffect(firstCard);
            }
            
            // UI ì—…ë°ì´íŠ¸ (ì¤‘ìš”: ì¹´ë“œ ì„ íƒê¸°ë³´ë‹¤ ë¨¼ì € í˜¸ì¶œ)
            updateUI();
            createCardSelector();
            

            
            // ì²« ë²ˆì§¸ í”Œë ˆì´ì–´ê°€ AIì¸ ê²½ìš° AI í”Œë ˆì´ ì‹œì‘
            setTimeout(() => {
                if (gameState.players[gameState.currentPlayer].isAI) {
                    aiPlay();
                }
            }, 1500);
        }
        
        function applyFirstCardEffect(card) {
            // ì¡°ì»¤ê°€ ì²« ì¹´ë“œì¸ ê²½ìš° ì¦‰ì‹œ ììœ  í”Œë ˆì´ ìƒíƒœë¡œ
            if (card.type === 'joker') {
                gameState.currentSuit = 'â™ ï¸';
                gameState.currentRank = 'free';

                return;
            }
            
            // ì‹œì‘ ì¹´ë“œê°€ ê³µê²© ì¹´ë“œ(2, A)ì¼ ê²½ìš° ì²« í”Œë ˆì´ì–´ì—ê²Œ íš¨ê³¼ ì ìš©
            if (card.rank === 'A' || card.rank === '2') {
                addAttackCard(card, -1); // -1ì€ ë±ì—ì„œ ë‚˜ì˜¨ ì¹´ë“œë¥¼ ì˜ë¯¸
            }
        }
        
        // UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜ë“¤
        function updateUI() {
            for (let i = 0; i < 4; i++) {
                updatePlayerCards(i);
            }
            updateCurrentCard();
            updateTurnIndicator();
            updateDeckDisplay();
        }
        
        function updatePlayerCards(playerIndex) {
            const player = gameState.players[playerIndex];
            const cardsContainer = document.getElementById(`cards-${playerIndex}`);
            const playerContainer = document.getElementById(`player-${playerIndex}`);
            
            if (!cardsContainer) {
                return;
            }
            
            cardsContainer.innerHTML = '';
            

            
            // ë´‡ ìƒíƒœ í‘œì‹œ ì—…ë°ì´íŠ¸
            if (playerIndex !== 0) {
                if (gameState.currentPlayer === playerIndex) {
                    playerContainer.classList.remove('inactive');
                    playerContainer.classList.add('active');
                } else {
                    playerContainer.classList.remove('active');
                    playerContainer.classList.add('inactive');
                }
            }
            
            player.hand.forEach((card, cardIndex) => {
                const cardElement = document.createElement('div');
                
                // í”Œë ˆì´ì–´ëŠ” ì •ë©´ ì¹´ë“œ, AIëŠ” ë’·ë©´ ì¹´ë“œ
                if (playerIndex === 0) {
                    // í”Œë ˆì´ì–´ ì¹´ë“œ (ì •ë©´, í´ë¦­ ê°€ëŠ¥)
                    cardElement.className = 'card';
                    
                    // í„°ì¹˜ ì´ë²¤íŠ¸ ë³€ìˆ˜
                    let touchStartTime = 0;
                    let touchStartX = 0;
                    let touchStartY = 0;
                    let isTouchMoved = false;
                    
                    // í´ë¦­ ì´ë²¤íŠ¸
                    cardElement.onclick = (e) => {
                        // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
                        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                            return;
                        }
                        playCard(0, cardIndex);
                    };
                    
                    // í„°ì¹˜ ì‹œì‘
                    cardElement.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        touchStartTime = Date.now();
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;
                        isTouchMoved = false;
                        
                        // í„°ì¹˜ í”¼ë“œë°±
                        cardElement.style.transform = 'translateY(-0.5rem) scale(1.05)';
                    }, { passive: false });
                    
                    // í„°ì¹˜ ì´ë™
                    cardElement.addEventListener('touchmove', (e) => {
                        const touch = e.touches[0];
                        const moveDistance = Math.sqrt(
                            Math.pow(touch.clientX - touchStartX, 2) +
                            Math.pow(touch.clientY - touchStartY, 2)
                        );
                        
                        if (moveDistance > 10) {
                            isTouchMoved = true;
                            // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                            cardElement.style.transform = '';
                        }
                    });
                    
                    // í„°ì¹˜ ì¢…ë£Œ
                    cardElement.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        const touchEndTime = Date.now();
                        const touchDuration = touchEndTime - touchStartTime;
                        
                        // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                        cardElement.style.transform = '';
                        
                        // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì¹´ë“œ í”Œë ˆì´
                        if (touchDuration < 300 && !isTouchMoved) {
                            playCard(0, cardIndex);
                        }
                    }, { passive: false });
                    
                    // ì¹´ë“œ ì´ë¯¸ì§€ ì„¤ì • (img íƒœê·¸ ì‚¬ìš©)
                    const imagePath = getCardImagePath(card);
                    const imgElement = document.createElement('img');
                    imgElement.src = imagePath;
                    imgElement.alt = `${card.suit}${card.rank}`;
                    cardElement.appendChild(imgElement);
                    

                    
                    // ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œì¸ì§€ í™•ì¸
                    if (canPlayCard(card)) {
                        cardElement.classList.add('playable');
                    }
                } else {
                    // AI ì¹´ë“œ (ë’·ë©´)
                    cardElement.className = 'ai-card';
                    
                    // AI ì¹´ë“œ ë’·ë©´ ì´ë¯¸ì§€ ì„¤ì • (img íƒœê·¸ ì‚¬ìš©)
                    const imgElement = document.createElement('img');
                    imgElement.src = '../solitaire/cards/back.png';
                    imgElement.alt = 'ì¹´ë“œ ë’·ë©´';
                    cardElement.appendChild(imgElement);
                }
                
                cardsContainer.appendChild(cardElement);
            });
        }
        
        function updateCurrentCard() {
            if (gameState.openDeck.length > 0) {
                const topCard = gameState.openDeck[gameState.openDeck.length - 1];
                
                // í˜„ì¬ ì¹´ë“œ ì´ë¯¸ì§€ ì„¤ì •
                const imagePath = getCardImagePath(topCard);
                
                // open-deckì— img íƒœê·¸ë¡œ ì´ë¯¸ì§€ ì ìš©
                const openDeckElement = document.getElementById('open-deck');
                openDeckElement.innerHTML = '';
                
                const imgElement = document.createElement('img');
                imgElement.src = imagePath;
                imgElement.alt = `${topCard.suit}${topCard.rank}`;
                openDeckElement.appendChild(imgElement);
                

            }
        }
        
        function updateDeckDisplay() {
            const deckElement = document.getElementById('deck');
            const deckCountElement = document.getElementById('deck-count');
            
            deckCountElement.textContent = `${gameState.deck.length}ì¥`;
            
            // ë±ì´ 0ì¥ì¼ ë•Œë§Œ ìˆ¨ê¸°ê¸° (ì‚¬ìš©ì ìš”êµ¬ì‚¬í•­)
            if (gameState.deck.length === 0) {
                deckElement.style.display = 'none';
            } else {
                deckElement.style.display = 'block';
            }
        }
        

        
        function updateTurnIndicator() {
            for (let i = 1; i < 4; i++) {
                const playerContainer = document.getElementById(`player-${i}`);
                if (playerContainer) {
                    if (gameState.currentPlayer === i) {
                        playerContainer.classList.remove('inactive');
                        playerContainer.classList.add('active');
                    } else {
                        playerContainer.classList.remove('active');
                        playerContainer.classList.add('inactive');
                    }
                }
            }
        }
        

        
        function getCardImagePath(card) {
            if (card.type === 'joker') {
                return `../solitaire/cards/joker-${card.color}.png`;
            }
            
            // ë¬´ëŠ¬ ë³€í™˜
            let suitName = '';
            switch (card.suit) {
                case 'â™ ï¸': suitName = 'spades'; break;
                case 'â™¥ï¸': suitName = 'hearts'; break;
                case 'â™¦ï¸': suitName = 'diamonds'; break;
                case 'â™£ï¸': suitName = 'clubs'; break;
            }
            
            // ë­í¬ ë³€í™˜ (ace, jack, queen, kingì€ ê·¸ëŒ€ë¡œ, ìˆ«ìëŠ” ê·¸ëŒ€ë¡œ)
            let rankName = card.rank.toLowerCase();
            if (rankName === 'a') rankName = 'ace';
            if (rankName === 'j') rankName = 'jack';
            if (rankName === 'q') rankName = 'queen';
            if (rankName === 'k') rankName = 'king';
            
            return `../solitaire/cards/${suitName}-${rankName}.png`;
        }
        

        
        // ì¹´ë“œ ê²Œì„ ë¡œì§
        function canPlayCard(card) {
            // ê³µê²©ì„ ë°›ê³  ìˆëŠ” ìƒí™©ì—ì„œì˜ ì²˜ë¦¬
            if (gameState.attackStack.length > 0) {
                // ì²« ë²ˆì§¸ ì¹´ë“œê°€ ë±ì—ì„œ ë‚˜ì˜¨ ê³µê²© ì¹´ë“œì¸ ê²½ìš° (ê²Œì„ ì‹œì‘)
                // ì¼ë°˜ ê·œì¹™ê³¼ ê³µê²© ë°©ì–´ ê·œì¹™ ë‘˜ ë‹¤ ì ìš©
                if (gameState.attackStack.length === 1 && gameState.attackStack[0].player === -1) {
                    const normalRule = card.suit === gameState.currentSuit || card.rank === gameState.currentRank || card.type === 'joker';
                    const defenseRule = canDefendAttack(card);
    
                    return normalRule || defenseRule;
                }
                
                // ì¼ë°˜ì ì¸ ê³µê²© ìƒí™©ì—ì„œëŠ” ë°©ì–´ ì¹´ë“œë§Œ ë‚¼ ìˆ˜ ìˆìŒ
                return canDefendAttack(card);
            }
            
            // ì¡°ì»¤ ê³µê²© í›„ ììœ  í”Œë ˆì´ ìƒíƒœ
            if (gameState.currentRank === 'free') {
                return true; // ì•„ë¬´ ì¹´ë“œë‚˜ ë‚¼ ìˆ˜ ìˆìŒ
            }
            
            // ì¼ë°˜ì ì¸ ê²½ìš°: ê°™ì€ ë¬´ëŠ¬ ë˜ëŠ” ê°™ì€ ìˆ«ì
            return card.suit === gameState.currentSuit || card.rank === gameState.currentRank || card.type === 'joker';
        }
        
        function playCard(playerIndex, cardIndex) {
            const player = gameState.players[playerIndex];
            const card = player.hand[cardIndex];
            
            // í”Œë ˆì´ì–´ í„´ì´ ì•„ë‹ˆê±°ë‚˜ ë‚¼ ìˆ˜ ì—†ëŠ” ì¹´ë“œì¸ ê²½ìš°
            if (gameState.currentPlayer !== playerIndex || !canPlayCard(card)) {
                if (playerIndex === 0) {
                    showGameMessage('ì§€ê¸ˆì€ ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹ˆê±°ë‚˜ ë‚¼ ìˆ˜ ì—†ëŠ” ì¹´ë“œì…ë‹ˆë‹¤!');
                }
                return;
            }
            
            // ì¹´ë“œ ìš”ì†Œ ì°¾ê¸° (ì• ë‹ˆë©”ì´ì…˜ìš©)
            let cardElement;
            if (playerIndex === 0) {
                const playerHand = document.getElementById('cards-0');
                cardElement = playerHand.children[cardIndex];
            } else {
                // AI ì¹´ë“œëŠ” AI ì˜ì—­ì—ì„œ ê°€ì ¸ì˜´
                const aiCards = document.getElementById(`cards-${playerIndex}`);
                cardElement = aiCards.children[0] || aiCards;
            }
            
            // ì¹´ë“œ ë‚´ê¸°
            const playedCard = player.hand.splice(cardIndex, 1)[0];
            
            // ì• ë‹ˆë©”ì´ì…˜ê³¼ í•¨ê»˜ ì¹´ë“œ ì²˜ë¦¬
            if (cardElement) {
                // ì¹´ë“œë¥¼ ëˆ„ë¥´ë©´ ì¦‰ì‹œ ìˆ¨ê¸°ê¸° (ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ ì „)
                cardElement.style.opacity = '0';
                cardElement.style.pointerEvents = 'none';
                
                animateCardToCenter(cardElement, playedCard, () => {
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì‹¤ì œ ê²Œì„ ë¡œì§ ì²˜ë¦¬
                    gameState.openDeck.push(playedCard);
                    
                    // AI ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ (AIì¸ ê²½ìš°ì—ë§Œ, K ì¹´ë“œê°€ ì•„ë‹Œ ê²½ìš°)
                    if (gameState.players[playerIndex].isAI && playedCard.rank !== 'K') {
                        gameState.aiProcessing = false;
                    }
                    
                    // ììœ  í”Œë ˆì´ ìƒíƒœ í™•ì¸
                    const wasFreePlay = gameState.currentRank === 'free';
                    
                    // ì²« ì¹´ë“œ ê³µê²© ì˜ˆì™¸ ìƒí™©ì—ì„œ ì¼ë°˜ ì¹´ë“œë¥¼ ë‚¸ ê²½ìš° ê³µê²©ìŠ¤íƒ ì´ˆê¸°í™”
                    if (gameState.attackStack.length === 1 && 
                        gameState.attackStack[0].player === -1 && 
                        playedCard.rank !== '2' && playedCard.rank !== 'A' && playedCard.type !== 'joker') {

                        clearAttackStack();
                    }
                    
                    // í˜„ì¬ ì¹´ë“œ ì •ë³´ ì—…ë°ì´íŠ¸
                    gameState.currentSuit = playedCard.suit;
                    gameState.currentRank = playedCard.rank;
                    
                    // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (ê°€ì¥ ë¨¼ì € ì²˜ë¦¬)
                    if (player.hand.length === 0) {
                        setTimeout(() => {
                            showGameEndMessage(`ğŸ‰ ${player.name}ì´(ê°€) ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`);
                        }, 100);
                        return;
                    }
                    
                    // ì¹´ë“œë¥¼ ë‚¸ í›„ 1ì¥ ë‚¨ì•˜ìœ¼ë©´ ì›ì¹´ë“œ ë²„íŠ¼ í™œì„±í™”
                    if (player.hand.length === 1) {
                        checkOnecardButton();
                    }
                    
                    // 7 ì¹´ë“œì¸ ê²½ìš° ì›ì¹´ë“œ ë²„íŠ¼ ê¸°íšŒë¥¼ ë¨¼ì € ì£¼ê³  ë¬´ëŠ¬ ì„ íƒ
                    if (playedCard.rank === '7') {
                        updateUI();
                        
                        // ë¬´ëŠ¬ ì„ íƒ ëŒ€ê¸° ìƒíƒœë¡œ ì„¤ì •
                        gameState.waitingForSuitSelection = true;
                        gameState.suitSelectionPlayerIndex = playerIndex;
                        
                        // ì›ì¹´ë“œ ë²„íŠ¼ì´ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ì²´í¬ ì œê±°)
                        if (!gameState.onecardButtonActive) {
                            proceedToSuitSelection();
                        } else {
                            // ì›ì¹´ë“œ ë²„íŠ¼ì´ í™œì„±í™”ë˜ì–´ ìˆë‹¤ë©´ ìµœëŒ€ 3.5ì´ˆ í›„ì— ë¬´ëŠ¬ ì„ íƒ
                            setTimeout(() => {
                                if (gameState.waitingForSuitSelection) {
                                    proceedToSuitSelection();
                                }
                            }, 3500);
                        }
                        
                        return; // ë¬´ëŠ¬ ì„ íƒ í›„ selectSuit í•¨ìˆ˜ì—ì„œ í„´ì„ ë„˜ê¹€
                    }
                    
                    // íŠ¹ìˆ˜ ì¹´ë“œ íš¨ê³¼ ì ìš© (7 ì¹´ë“œ ì œì™¸)
                    applyCardEffect(playedCard, playerIndex);
                    
                    // J ì¹´ë“œì¸ ê²½ìš° applyCardEffectì—ì„œ ì´ë¯¸ nextTurnì„ í˜¸ì¶œí–ˆìœ¼ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë„˜ê¸°ì§€ ì•ŠìŒ
                    if (playedCard.rank === 'J') {
                        updateUI();
                        return;
                    }
                    
                    // ê³µê²© ì¹´ë“œë¥¼ ë‚¸ ê²½ìš° ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ í„´ ë„˜ê¹€
                    if (playedCard.rank === '2' || playedCard.rank === 'A' || playedCard.type === 'joker') {
                        nextTurn();
                    } else if (playedCard.rank !== 'K') {
                        // ë‹¤ìŒ í„´ìœ¼ë¡œ (K ì¹´ë“œê°€ ì•„ë‹Œ ê²½ìš°)
                        nextTurn();
                    } else {
                        // K ì¹´ë“œ: ê°™ì€ í”Œë ˆì´ì–´ê°€ ë‹¤ì‹œ í”Œë ˆì´ (í„´ ë„˜ê¸°ì§€ ì•ŠìŒ)
                        setTimeout(() => {
                            if (gameState.players[gameState.currentPlayer].isAI) {
                                gameState.aiProcessing = false;
                                aiPlay();
                            } else {
                                gameState.aiProcessing = false;
                            }
                        }, 1000);
                    }
                    
                    updateUI();
                });
            } else {
                // ì• ë‹ˆë©”ì´ì…˜ ìš”ì†Œê°€ ì—†ëŠ” ê²½ìš° ë°”ë¡œ ì²˜ë¦¬
                gameState.openDeck.push(playedCard);
                updateUI();
            }
        }
        
        function applyCardEffect(card, playerIndex) {
            switch (card.rank) {
                case '2':
                    addAttackCard(card, playerIndex);
                    break;
                case 'A':
                    addAttackCard(card, playerIndex);
                    break;
                case 'J':
                    // ë‹¤ìŒ í”Œë ˆì´ì–´ í„´ ê±´ë„ˆë›°ê¸° (nextTurn ë‘ ë²ˆ í˜¸ì¶œ)
                    nextTurn(); // 1ë‹¨ê³„: ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ì´ë™
                    nextTurn(); // 2ë‹¨ê³„: ê·¸ í”Œë ˆì´ì–´ë¥¼ ê±´ë„ˆë›°ê³  ê·¸ ë‹¤ìŒ í”Œë ˆì´ì–´ë¡œ ì´ë™
                    break;
                case 'Q':
                    gameState.direction *= -1; // ë°©í–¥ ë°”ê¾¸ê¸°
                    break;
                case '7':
                    // 7 ì¹´ë“œëŠ” playCard í•¨ìˆ˜ì—ì„œ ë³„ë„ ì²˜ë¦¬ë¨
                    break;
            }
            
            if (card.type === 'joker') {
                addAttackCard(card, playerIndex);
            }
        }
        
        // ìƒˆë¡œìš´ ê³µê²© ì‹œìŠ¤í…œ
        function addAttackCard(card, playerIndex) {
            gameState.attackStack.push({
                card: card,
                player: playerIndex,
                value: getAttackValue(card)
            });
            

        }
        
        function getAttackValue(card) {
            if (card.type === 'joker') {
                return card.color === 'blue' ? 3 : 5;
            }
            switch (card.rank) {
                case '2': return 1;
                case 'A': return 2;
                default: return 0;
            }
        }
        
        function getTotalAttackValue() {
            return gameState.attackStack.reduce((total, attack) => total + attack.value, 0);
        }
        
        function canDefendAttack(card) {
            if (gameState.attackStack.length === 0) return false;
            
            const lastAttack = gameState.attackStack[gameState.attackStack.length - 1];
            const lastAttackCard = lastAttack.card;
            
            // ì¡°ì»¤ëŠ” ì¡°ì»¤ë¡œë§Œ ë§‰ì„ ìˆ˜ ìˆìŒ
            if (lastAttackCard.type === 'joker') {
                return card.type === 'joker';
            }
            
            // AëŠ” ì•„ë¬´ ë¬´ëŠ¬ì˜ Aë‚˜ ì¡°ì»¤ë¡œ ë§‰ì„ ìˆ˜ ìˆìŒ
            if (lastAttackCard.rank === 'A') {
                return card.rank === 'A' || card.type === 'joker';
            }
            
            // 2ëŠ” ì•„ë¬´ ë¬´ëŠ¬ì˜ 2 ë˜ëŠ” ê°™ì€ ë¬´ëŠ¬ì˜ A ë˜ëŠ” ì¡°ì»¤ë¡œ ë§‰ì„ ìˆ˜ ìˆìŒ
            if (lastAttackCard.rank === '2') {
                return card.rank === '2' || 
                       (card.rank === 'A' && card.suit === lastAttackCard.suit) || 
                       card.type === 'joker';
            }
            
            return false;
        }
        
        function clearAttackStack() {
            gameState.attackStack = [];
        }
        
        function showSuitSelector() {
            document.getElementById('suit-selector').style.display = 'block';
        }
        
        function hideSuitSelector() {
            document.getElementById('suit-selector').style.display = 'none';
        }
        
        function selectSuit(suit) {
            gameState.currentSuit = suit;
            hideSuitSelector();
            
            showGameMessage(`âœ… ë¬´ëŠ¬ë¥¼ ${suit}ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!`);
            updateUI();
            
            // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (ë¬´ëŠ¬ ì„ íƒ í›„ì—ë„ ì²´í¬)
            const currentPlayer = gameState.players[gameState.currentPlayer];
            if (currentPlayer.hand.length === 0) {
                setTimeout(() => {
                    showGameEndMessage(`ğŸ‰ ${currentPlayer.name}ì´(ê°€) ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`);
                }, 100);
                return;
            }

            if (gameState.players[gameState.currentPlayer].hand.length > 0) {
                nextTurn();
            }
        }
        
        function aiSelectSuit(aiIndex) {
            const ai = gameState.players[aiIndex];
            const suitCounts = { 'â™ ï¸': 0, 'â™¥ï¸': 0, 'â™¦ï¸': 0, 'â™£ï¸': 0 };
            
            // AI ì†íŒ¨ì—ì„œ ê°€ì¥ ë§ì€ ë¬´ëŠ¬ ê³„ì‚°
            ai.hand.forEach(card => {
                if (suitCounts[card.suit] !== undefined) {
                    suitCounts[card.suit]++;
                }
            });
            
            const bestSuit = Object.keys(suitCounts).reduce((a, b) => 
                suitCounts[a] > suitCounts[b] ? a : b
            );
            
            gameState.currentSuit = bestSuit;
            
            showGameMessage(`ğŸ¤– ${ai.name}ì´(ê°€) ë¬´ëŠ¬ë¥¼ ${bestSuit}ë¡œ ë³€ê²½í–ˆìŠµë‹ˆë‹¤!`);
            updateUI();
            
            // ìŠ¹ë¦¬ ì¡°ê±´ í™•ì¸ (AI ë¬´ëŠ¬ ì„ íƒ í›„ì—ë„ ì²´í¬)
            if (ai.hand.length === 0) {
                setTimeout(() => {
                    showGameEndMessage(`ğŸ‰ ${ai.name}ì´(ê°€) ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`);
                }, 100);
                return;
            }

            if (gameState.players[gameState.currentPlayer].hand.length > 0) {
                nextTurn();
            }
        }
        
        function nextTurn() {
            let nextPlayer = gameState.currentPlayer + gameState.direction;
            
            if (nextPlayer >= 4) nextPlayer = 0;
            if (nextPlayer < 0) nextPlayer = 3;
            
            gameState.currentPlayer = nextPlayer;
            
            updateTurnIndicator();
            
            // ê³µê²© ìŠ¤íƒì´ ìˆìœ¼ë©´ ê³µê²© ì²˜ë¦¬
            if (gameState.attackStack.length > 0) {
                handleAttackOnTurn();
                return;
            }
            

            if (gameState.players[gameState.currentPlayer].isAI) {
                setTimeout(() => {
                    aiPlay();
                }, 1000);
            }
        }
        
        function handleAttackOnTurn() {
            const currentPlayer = gameState.players[gameState.currentPlayer];
            const canDefend = currentPlayer.hand.some(card => canDefendAttack(card));
            
            if (!canDefend) {
                executeAttackDamage(gameState.currentPlayer);
            } else if (currentPlayer.isAI) {
                setTimeout(() => {
                    aiPlay();
                }, 1000);
            }
        }
        
        function executeAttackDamage(playerIndex) {
            const player = gameState.players[playerIndex];
            const totalDamage = getTotalAttackValue();
            

            
            // ì¡°ì»¤ ê³µê²©ì´ ìˆì—ˆëŠ”ì§€ í™•ì¸
            const hasJokerAttack = gameState.attackStack.some(attack => attack.card.type === 'joker');
            
            checkAndReshuffleDeck();
            animateCardToPlayer(playerIndex, totalDamage, () => {
                for (let i = 0; i < totalDamage; i++) {
                    if (gameState.deck.length > 0) {
                        player.hand.push(gameState.deck.pop());
                        updateDeckDisplay();
                    }
                }
                
                if (!player.isAI) {
                    showGameMessage(`ê³µê²©ì„ ë§‰ì§€ ëª»í•´ ì¹´ë“œ ${totalDamage}ì¥ì„ ê°€ì ¸ê°”ìŠµë‹ˆë‹¤!`);
                }
                
                finishAttackSequence(playerIndex, totalDamage, hasJokerAttack);
            });
        }
        
        function finishAttackSequence(playerIndex, totalDamage, hasJokerAttack) {
            const player = gameState.players[playerIndex];
            

            
            if (hasJokerAttack) {
                gameState.currentSuit = 'â™ ï¸';
                gameState.currentRank = 'free';
            }
            
            clearAttackStack();
            updateUI();
            nextTurn();
        }
        
        function drawCard() {
            if (gameState.currentPlayer !== 0) {
                showGameMessage('ì§€ê¸ˆì€ ë‹¹ì‹ ì˜ í„´ì´ ì•„ë‹™ë‹ˆë‹¤!');
                return;
            }
            
            checkAndReshuffleDeck();
            
            if (gameState.deck.length === 0) {
                showGameMessage('ë±ì— ì¹´ë“œê°€ ì—†ìŠµë‹ˆë‹¤!');
                return;
            }
            
            if (gameState.attackStack.length > 0) {
                const canDefend = gameState.players[0].hand.some(card => canDefendAttack(card));
                if (!canDefend) {
                    executeAttackDamage(0);
                    return;
                }
            }
            animateCardToPlayer(0, 1, () => {
                const drawnCard = gameState.deck.pop();
                gameState.players[0].hand.push(drawnCard);
                updateDeckDisplay();
                nextTurn();
                updateUI();
            });
        }
        
        function checkOnecardButton() {
            const onecardPlayers = gameState.players.filter(player => player.hand.length === 1);
            
            if (onecardPlayers.length > 0 && !gameState.onecardButtonActive) {
                showOnecardButton();
            } else if (onecardPlayers.length === 0 && gameState.onecardButtonActive) {
                hideOnecardButton();
            }
        }
        
        function showOnecardButton() {
            if (gameState.onecardButtonActive) {
                return;
            }
            
            gameState.onecardButtonActive = true;
            document.getElementById('onecard-button').style.display = 'block';
            if (gameState.onecardTimer) {
                clearTimeout(gameState.onecardTimer);
            }
            
            gameState.onecardTimer = setTimeout(() => {
                if (gameState.onecardButtonActive) {
                    aiOnecardCall();
                }
            }, 1000);
        }
        
        function hideOnecardButton() {
            gameState.onecardButtonActive = false;
            document.getElementById('onecard-button').style.display = 'none';
            
            if (gameState.onecardTimer) {
                clearTimeout(gameState.onecardTimer);
                gameState.onecardTimer = null;
            }
            
            if (gameState.waitingForSuitSelection) {
                setTimeout(() => {
                    proceedToSuitSelection();
                }, 500);
            }
        }
        
        function proceedToSuitSelection() {
            if (!gameState.waitingForSuitSelection) return;
            
            const playerIndex = gameState.suitSelectionPlayerIndex;
            
            if (!gameState.players[playerIndex].isAI) {
                showSuitSelector();
            } else {
                aiSelectSuit(playerIndex);
            }
            
            gameState.waitingForSuitSelection = false;
            gameState.suitSelectionPlayerIndex = -1;
        }
        
        function onecardCall() {
            if (!gameState.onecardButtonActive) return;
            
            const onecardAI = gameState.players.find(p => p.hand.length === 1 && p.isAI);
            if (onecardAI) {
                showGameMessage(`ğŸ‰ í”Œë ˆì´ì–´ê°€ ë¨¼ì € ì›ì¹´ë“œë¥¼ ì™¸ì³¤ìŠµë‹ˆë‹¤! ${onecardAI.name}ì´ ì¹´ë“œ 1ì¥ì„ ê°€ì ¸ê°‘ë‹ˆë‹¤.`);
                if (gameState.deck.length > 0) {
                    onecardAI.hand.push(gameState.deck.pop());
                    updateDeckDisplay();
                }
                updateUI();
            } else {
                showGameMessage('ğŸ‰ í”Œë ˆì´ì–´ê°€ ì›ì¹´ë“œë¥¼ ì™¸ì³¤ìŠµë‹ˆë‹¤!');
            }
            
            hideOnecardButton();
        }
        
        function aiOnecardCall() {
            if (!gameState.onecardButtonActive) return;
            
            const onecardPlayer = gameState.players.find(p => p.hand.length === 1);
            if (onecardPlayer && !onecardPlayer.isAI) {
                showGameMessage('ğŸ˜± AIê°€ ë¨¼ì € ì›ì¹´ë“œë¥¼ ì™¸ì³¤ìŠµë‹ˆë‹¤! ì¹´ë“œ 1ì¥ì„ ê°€ì ¸ê°‘ë‹ˆë‹¤.');
                if (gameState.deck.length > 0) {
                    gameState.players[0].hand.push(gameState.deck.pop());
                    updateDeckDisplay();
                }
            } else {
                const aiPlayer = gameState.players.find(p => p.hand.length === 1 && p.isAI);
                if (aiPlayer) {
                    showGameMessage(`ğŸ¤– ${aiPlayer.name}ì´(ê°€) ì›ì¹´ë“œë¥¼ ì™¸ì³¤ìŠµë‹ˆë‹¤!`);
                }
            }
            
            hideOnecardButton();
            updateUI();
        }
        

        

        

        
        // ë©”ì¸ë©”ë‰´ë¡œ ì´ë™
        function goToMainMenu() {
            // ê²Œì„ ì¢…ë£Œ íŒì—… ë‹«ê¸°
            const gameEndMessage = document.getElementById('game-end-message');
            if (gameEndMessage) {
                gameEndMessage.remove();
            }
            
            // ë©”ì¸ë©”ë‰´ë¡œ ì´ë™
            location.href = '../../index.html';
        }
        
        // AI ë¡œì§
        function aiPlay() {
            const aiIndex = gameState.currentPlayer;
            const ai = gameState.players[aiIndex];
            
            // AIê°€ ì•„ë‹Œ ê²½ìš° return
            if (!ai.isAI) {
                return;
            }
            
            // ì´ë¯¸ AIê°€ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
            if (gameState.aiProcessing) {
                return;
            }
            
            // AI ì²˜ë¦¬ ì‹œì‘ í”Œë˜ê·¸ ì„¤ì •
            gameState.aiProcessing = true;
            
            // AIê°€ ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œë“¤ ì°¾ê¸°
            const playableCards = ai.hand.map((card, index) => ({ card, index }))
                .filter(({ card }) => canPlayCard(card));
                

            
            if (playableCards.length > 0) {
                // AI ì „ëµì— ë”°ë¼ ì¹´ë“œ ì„ íƒ
                const selectedCard = selectAICard(ai, playableCards);
                playCard(aiIndex, selectedCard.index);
            } else {
                // ë±ì´ ë¹„ì—ˆìœ¼ë©´ ì¬ì…”í”Œ
                checkAndReshuffleDeck();
                
                // ë‚¼ ìˆ˜ ìˆëŠ” ì¹´ë“œê°€ ì—†ìœ¼ë©´ ë±ì—ì„œ ê°€ì ¸ì˜¤ê¸°
                if (gameState.deck.length > 0) {

                    animateCardToPlayer(aiIndex, 1, () => {
                        const drawnCard = gameState.deck.pop();
                        ai.hand.push(drawnCard);
                        updateDeckDisplay(); // ë± ì¹´ìš´íŠ¸ ì—…ë°ì´íŠ¸
                        
                        // AI ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ
                        gameState.aiProcessing = false;
                        
                        // AIëŠ” ì¹´ë“œë¥¼ ë½‘ìœ¼ë©´ í„´ì´ ìë™ìœ¼ë¡œ ë„˜ì–´ê°
                        nextTurn();
                        updateUI();
                    });
                } else {
                    // ë±ì— ì¹´ë“œê°€ ì—†ëŠ” ê²½ìš° (ì¬ì…”í”Œë„ ë¶ˆê°€ëŠ¥í•œ ìƒí™©)

                    
                    // AI ì²˜ë¦¬ ì™„ë£Œ í”Œë˜ê·¸ í•´ì œ
                    gameState.aiProcessing = false;
                    
                    nextTurn();
                    updateUI();
                }
            }
        }
        
        function selectAICard(ai, playableCards) {
            // AI ìš°ì„ ìˆœìœ„ ì „ëµ
            
            // 1. ìŠ¹ë¦¬ í™•ì • - ë§ˆì§€ë§‰ ì¹´ë“œ
            if (ai.hand.length === 1) {
                return playableCards[0];
            }
            
            // 2. ì „ëµì  ê³µê²© - ì¹´ë“œ ìˆ˜ê°€ ì ì€ í”Œë ˆì´ì–´ ê³µê²©
            const attackCards = playableCards.filter(({ card }) => 
                card.rank === '2' || card.rank === 'A' || card.type === 'joker'
            );
            
            if (attackCards.length > 0) {
                const minCardPlayer = gameState.players.reduce((min, player, index) => {
                    if (index === gameState.currentPlayer) return min;
                    return player.hand.length < gameState.players[min].hand.length ? index : min;
                }, 0);
                
                // ê°€ì¥ ì ì€ ì¹´ë“œë¥¼ ê°€ì§„ í”Œë ˆì´ì–´ê°€ ìˆê³ , ê·¸ í”Œë ˆì´ì–´ê°€ ì›ì¹´ë“œ ìƒíƒœë¼ë©´ ê³µê²©
                if (gameState.players[minCardPlayer].hand.length <= 2) {
                    // ê°€ì¥ ê°•í•œ ê³µê²© ì¹´ë“œ ì„ íƒ
                    const strongestAttack = attackCards.reduce((strongest, current) => {
                        const strongestPower = getAttackPower(strongest.card);
                        const currentPower = getAttackPower(current.card);
                        return currentPower > strongestPower ? current : strongest;
                    });
                    return strongestAttack;
                }
            }
            
            // 3. ìœ„ê¸° ë°©ì–´ - ê³µê²©ë°›ì•˜ì„ ë•Œ ë°©ì–´
            if (gameState.attackStack.length > 0) {
                const defenseCards = playableCards.filter(({ card }) => canDefendAttack(card));
                
                if (defenseCards.length > 0) {
                    // ê°€ì¥ ì•½í•œ ë°©ì–´ ì¹´ë“œ ì‚¬ìš© (ê°•í•œ ì¹´ë“œ ë³´ì¡´)
                    return defenseCards.reduce((weakest, current) => {
                        const weakestPower = getAttackPower(weakest.card);
                        const currentPower = getAttackPower(current.card);
                        return currentPower < weakestPower ? current : weakest;
                    });
                }
            }
            
            // 4. íŠ¹ìˆ˜ ëŠ¥ë ¥ ì¹´ë“œ ì‚¬ìš©
            const abilityCards = playableCards.filter(({ card }) => 
                card.rank === 'J' || card.rank === 'Q' || card.rank === 'K' || card.rank === '7'
            );
            
            if (abilityCards.length > 0) {
                // ë‹¤ìŒ í”Œë ˆì´ì–´ê°€ ì¹´ë“œ ì ìœ¼ë©´ J(í„´ ê±´ë„ˆë›°ê¸°) ìš°ì„ 
                const nextPlayerIndex = getNextPlayerIndex();
                if (gameState.players[nextPlayerIndex].hand.length <= 3) {
                    const skipCard = abilityCards.find(({ card }) => card.rank === 'J');
                    if (skipCard) return skipCard;
                }
                
                // K(í•œ ë²ˆ ë”) ì¹´ë“œê°€ ìˆìœ¼ë©´ ì‚¬ìš©
                const kingCard = abilityCards.find(({ card }) => card.rank === 'K');
                if (kingCard) return kingCard;
                
                // 7(ë¬´ëŠ¬ ë³€ê²½) ì¹´ë“œ ì‚¬ìš©
                const sevenCard = abilityCards.find(({ card }) => card.rank === '7');
                if (sevenCard) return sevenCard;
            }
            
            // 5. ì¼ë°˜ ì¹´ë“œ ì¤‘ ê°€ì¥ ë†’ì€ ìˆ«ì (ë³´ì¡´ ì „ëµ)
            const normalCards = playableCards.filter(({ card }) => 
                !['A', '2', 'J', 'Q', 'K', '7'].includes(card.rank) && card.type !== 'joker'
            );
            
            if (normalCards.length > 0) {
                return normalCards.reduce((highest, current) => {
                    const highestValue = getCardValue(highest.card);
                    const currentValue = getCardValue(current.card);
                    return currentValue > highestValue ? current : highest;
                });
            }
            
            // 6. ë§ˆì§€ë§‰ ì„ íƒ - ì²« ë²ˆì§¸ ê°€ëŠ¥í•œ ì¹´ë“œ
            return playableCards[0];
        }
        
        function getAttackPower(card) {
            if (card.type === 'joker') {
                return card.color === 'red' ? 5 : 3;
            }
            switch (card.rank) {
                case 'A': return 2;
                case '2': return 1;
                default: return 0;
            }
        }
        

        
        function getCardValue(card) {
            const values = {
                'A': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7,
                '8': 8, '9': 9, '10': 10, 'J': 11, 'Q': 12, 'K': 13
            };
            return values[card.rank] || 0;
        }
        
        function getNextPlayerIndex() {
            let next = gameState.currentPlayer + gameState.direction;
            if (next >= 4) next = 0;
            if (next < 0) next = 3;
            return next;
        }
        
        // ê²Œì„ ë©”ì‹œì§€ í‘œì‹œ í•¨ìˆ˜
        function showGameMessage(message) {
            // ê¸°ì¡´ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ì œê±°
            const existingMessage = document.getElementById('game-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // ë©”ì‹œì§€ ìš”ì†Œ ìƒì„±
            const messageElement = document.createElement('div');
            messageElement.id = 'game-message';
            messageElement.textContent = message;
            messageElement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 20px 30px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                z-index: 1000;
                text-align: center;
                min-width: 200px;
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
                animation: fadeInOut 2.5s ease-in-out forwards;
            `;
            
            // CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
            if (!document.getElementById('message-style')) {
                const style = document.createElement('style');
                style.id = 'message-style';
                style.textContent = `
                    @keyframes fadeInOut {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        20% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                        100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // ë©”ì‹œì§€ í‘œì‹œ
            document.body.appendChild(messageElement);
            
            // 2.5ì´ˆ í›„ ìë™ ì œê±°
            setTimeout(() => {
                if (messageElement && messageElement.parentNode) {
                    messageElement.remove();
                }
            }, 2500);
        }
        
        // ê²Œì„ ì¢…ë£Œ ë©”ì‹œì§€ (ë²„íŠ¼ í¬í•¨)
        function showGameEndMessage(message) {
            // ê¸°ì¡´ ë©”ì‹œì§€ê°€ ìˆìœ¼ë©´ ì œê±°
            const existingMessage = document.getElementById('game-end-message');
            if (existingMessage) {
                existingMessage.remove();
            }
            
            // ë©”ì‹œì§€ ìš”ì†Œ ìƒì„±
            const messageElement = document.createElement('div');
            messageElement.id = 'game-end-message';
            messageElement.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.9);
                color: white;
                padding: 40px;
                border-radius: 20px;
                font-size: 24px;
                font-weight: bold;
                z-index: 2000;
                text-align: center;
                min-width: 400px;
                box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
                animation: gameEndFadeIn 0.5s ease-out forwards;
            `;
            
            // ë‚´ìš© êµ¬ì„±
            messageElement.innerHTML = `
                <div style="margin-bottom: 30px; font-size: 28px;">${message}</div>
                <div style="display: flex; gap: 20px; justify-content: center;">
                    <button onclick="startNewGame()" style="
                        background: linear-gradient(135deg, #27AE60, #2ECC71);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        ğŸ® ë‹¤ì‹œí•˜ê¸°
                    </button>
                    <button onclick="goToMainMenu()" style="
                        background: linear-gradient(135deg, #3498DB, #2980B9);
                        color: white;
                        border: none;
                        padding: 15px 30px;
                        border-radius: 10px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        ğŸ  ë©”ì¸ë©”ë‰´
                    </button>
                </div>
            `;
            
            // CSS ì• ë‹ˆë©”ì´ì…˜ ì¶”ê°€
            if (!document.getElementById('game-end-style')) {
                const style = document.createElement('style');
                style.id = 'game-end-style';
                style.textContent = `
                    @keyframes gameEndFadeIn {
                        0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                        100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // ë©”ì‹œì§€ í‘œì‹œ
            document.body.appendChild(messageElement);
        }
        
        // ì¹´ë“œ ì• ë‹ˆë©”ì´ì…˜ í•¨ìˆ˜
        function animateCardToCenter(fromElement, card, callback) {
            // ì‹œì‘ ìœ„ì¹˜
            const fromRect = fromElement.getBoundingClientRect();
            const centerElement = document.getElementById('open-deck');
            const centerRect = centerElement.getBoundingClientRect();
            
            // ì• ë‹ˆë©”ì´ì…˜ ì¹´ë“œ ìƒì„±
            const animCard = document.createElement('div');
            animCard.className = 'card-animation';
            animCard.style.left = fromRect.left + 'px';
            animCard.style.top = fromRect.top + 'px';
            
            // ì¹´ë“œ ì´ë¯¸ì§€ ì„¤ì •
            const imagePath = getCardImagePath(card);
            const imgElement = document.createElement('img');
            imgElement.src = imagePath;
            imgElement.alt = `${card.suit}${card.rank}`;
            animCard.appendChild(imgElement);
            
            document.body.appendChild(animCard);
            
            // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const deltaX = centerRect.left - fromRect.left;
            const deltaY = centerRect.top - fromRect.top;
            
            // CSS ë³€ìˆ˜ ì„¤ì • (rem ë‹¨ìœ„ë¡œ ë³€í™˜)
            const remX = deltaX / parseFloat(getComputedStyle(document.documentElement).fontSize);
            const remY = deltaY / parseFloat(getComputedStyle(document.documentElement).fontSize);
            animCard.style.setProperty('--target-x', remX + 'rem');
            animCard.style.setProperty('--target-y', remY + 'rem');
            
            // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ìì—°ìŠ¤ëŸ½ê²Œ)
            setTimeout(() => {
                animCard.style.animation = 'flyToCenter 0.6s cubic-bezier(0.4, 0.0, 0.2, 1) forwards';
            }, 30);
            
            // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì •ë¦¬
            setTimeout(() => {
                document.body.removeChild(animCard);
                if (callback) callback();
            }, 650);
        }
        
        function animateCardToPlayer(playerIndex, count, callback) {
            const deckElement = document.getElementById('deck');
            const deckRect = deckElement.getBoundingClientRect();
            
            let playerElement;
            if (playerIndex === 0) {
                playerElement = document.querySelector('.player-south');
            } else {
                playerElement = document.getElementById(`player-${playerIndex}`);
            }
            const playerRect = playerElement.getBoundingClientRect();
            
            let completed = 0;
            
            for (let i = 0; i < count; i++) {
                setTimeout(() => {
                    // ì• ë‹ˆë©”ì´ì…˜ ì¹´ë“œ ìƒì„±
                    const animCard = document.createElement('div');
                    animCard.className = 'card-back-animation';
                    animCard.style.left = deckRect.left + 'px';
                    animCard.style.top = deckRect.top + 'px';
                    
                    // ë’·ë©´ ì¹´ë“œ ì´ë¯¸ì§€ ì„¤ì •
                    const imgElement = document.createElement('img');
                    imgElement.src = '../solitaire/cards/back.png';
                    imgElement.alt = 'ì¹´ë“œ ë’·ë©´';
                    animCard.appendChild(imgElement);
                    
                    document.body.appendChild(animCard);
                    
                    // ëª©í‘œ ìœ„ì¹˜ ê³„ì‚° (ëª¨ë“  í”Œë ˆì´ì–´ ì¤‘ì•™ìœ¼ë¡œ)
                    let deltaX, deltaY;
                    if (playerIndex === 0) {
                        // í”Œë ˆì´ì–´ì˜ ê²½ìš° ì¹´ë“œ ì˜ì—­ ì¤‘ì•™ìœ¼ë¡œ
                        const cardAreaCenter = playerRect.left + (playerRect.width / 2);
                        deltaX = cardAreaCenter - deckRect.left + (i * 15) - 50; // ì¹´ë“œë“¤ì´ ì•½ê°„ì”© ê²¹ì¹˜ë„ë¡
                        deltaY = playerRect.top - deckRect.top + 50; // í”Œë ˆì´ì–´ ì¹´ë“œ ì˜ì—­ ìƒë‹¨ìª½ìœ¼ë¡œ
                    } else {
                        // AIì˜ ê²½ìš° ê° í”Œë ˆì´ì–´ ì˜ì—­ ì¤‘ì•™ìœ¼ë¡œ
                        const cardAreaCenter = playerRect.left + (playerRect.width / 2);
                        deltaX = cardAreaCenter - deckRect.left + (i * 10) - 50; // ì¹´ë“œë“¤ì´ ì•½ê°„ì”© ê²¹ì¹˜ë„ë¡
                        deltaY = playerRect.top - deckRect.top + (playerRect.height / 2) - 50; // í”Œë ˆì´ì–´ ì˜ì—­ ì¤‘ì•™ìœ¼ë¡œ
                    }
                    
                    // CSS ë³€ìˆ˜ ì„¤ì • (rem ë‹¨ìœ„ë¡œ ë³€í™˜)
                    const remX = deltaX / parseFloat(getComputedStyle(document.documentElement).fontSize);
                    const remY = deltaY / parseFloat(getComputedStyle(document.documentElement).fontSize);
                    animCard.style.setProperty('--target-x', remX + 'rem');
                    animCard.style.setProperty('--target-y', remY + 'rem');
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì‹œì‘ (ìì—°ìŠ¤ëŸ½ê²Œ)
                    setTimeout(() => {
                        animCard.style.animation = 'flyToPlayer 0.6s cubic-bezier(0.4, 0.0, 0.2, 1) forwards';
                    }, 30);
                    
                    // ì• ë‹ˆë©”ì´ì…˜ ì™„ë£Œ í›„ ì •ë¦¬
                    setTimeout(() => {
                        document.body.removeChild(animCard);
                        completed++;
                        if (completed === count && callback) {
                            callback();
                        }
                    }, 650);
                }, i * 100); // ì¹´ë“œë§ˆë‹¤ 100ms ê°„ê²©ìœ¼ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ
            }
        }
        
        // ë± ì¬ì…”í”Œ (ë±ì´ ë–¨ì–´ì¡Œì„ ë•Œ)
        function reshuffleDeck() {
            if (gameState.deck.length === 0 && gameState.openDeck.length > 1) {
                // í˜„ì¬ ì¹´ë“œë¥¼ ì œì™¸í•˜ê³  ë‚˜ë¨¸ì§€ë¥¼ ë±ìœ¼ë¡œ ì´ë™
                const currentCard = gameState.openDeck.pop();
                gameState.deck = shuffleDeck([...gameState.openDeck]);
                gameState.openDeck = [currentCard];
                
    
                
                // ë± ì¬ì…”í”Œ ì‹œê°ì  íš¨ê³¼
                const deckElement = document.getElementById('deck');
                deckElement.style.transform = 'scale(1.1)';
                setTimeout(() => {
                    deckElement.style.transform = 'scale(1)';
                    updateUI();
                }, 300);
                
                return true; // ì¬ì…”í”Œ ì„±ê³µ
            }
            return false; // ì¬ì…”í”Œì´ ì¼ì–´ë‚˜ì§€ ì•ŠìŒ
        }
        
        function checkAndReshuffleDeck() {
            if (gameState.deck.length === 0) {
                reshuffleDeck();
                return true; // ì¬ì…”í”Œì´ ì¼ì–´ë‚¬ìŒì„ ì•Œë¦¼
            }
            return false; // ì¬ì…”í”Œì´ ì¼ì–´ë‚˜ì§€ ì•ŠìŒ
        }
    
    function createCardSelector() {
        const cardGrid = document.getElementById('card-grid');
        cardGrid.innerHTML = '';
        
        const suits = ['â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸'];
        const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        
        // ì¼ë°˜ ì¹´ë“œë“¤
        suits.forEach(suit => {
            ranks.forEach(rank => {
                const cardElement = document.createElement('div');
                cardElement.className = 'selectable-card';
                
                // í„°ì¹˜ ì´ë²¤íŠ¸ ë³€ìˆ˜
                let selectorTouchStartTime = 0;
                let selectorTouchStartX = 0;
                let selectorTouchStartY = 0;
                let selectorIsTouchMoved = false;
                
                // í´ë¦­ ì´ë²¤íŠ¸
                cardElement.onclick = (e) => {
                    // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
                    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                        return;
                    }
                    addCardToPlayer(suit, rank, 'normal');
                };
                
                // í„°ì¹˜ ì‹œì‘
                cardElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    selectorTouchStartTime = Date.now();
                    selectorTouchStartX = touch.clientX;
                    selectorTouchStartY = touch.clientY;
                    selectorIsTouchMoved = false;
                    
                    // í„°ì¹˜ í”¼ë“œë°±
                    cardElement.style.transform = 'scale(1.1)';
                }, { passive: false });
                
                // í„°ì¹˜ ì´ë™
                cardElement.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const moveDistance = Math.sqrt(
                        Math.pow(touch.clientX - selectorTouchStartX, 2) +
                        Math.pow(touch.clientY - selectorTouchStartY, 2)
                    );
                    
                    if (moveDistance > 10) {
                        selectorIsTouchMoved = true;
                        // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                        cardElement.style.transform = '';
                    }
                });
                
                // í„°ì¹˜ ì¢…ë£Œ
                cardElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - selectorTouchStartTime;
                    
                    // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                    cardElement.style.transform = '';
                    
                    // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì¹´ë“œ ì¶”ê°€
                    if (touchDuration < 300 && !selectorIsTouchMoved) {
                        addCardToPlayer(suit, rank, 'normal');
                    }
                }, { passive: false });
                
                // ì¹´ë“œ ì´ë¯¸ì§€ ì„¤ì •
                const card = { suit, rank, type: 'normal' };
                const imagePath = getCardImagePath(card);
                cardElement.style.backgroundImage = `url('${imagePath}')`;
                cardElement.style.backgroundSize = 'cover';
                cardElement.style.backgroundPosition = 'center';
                cardElement.style.backgroundRepeat = 'no-repeat';
                
                cardGrid.appendChild(cardElement);
            });
        });
        
        // ì¡°ì»¤ ì¹´ë“œë“¤
        const blueJoker = document.createElement('div');
        blueJoker.className = 'selectable-card';
        
        // íŒŒë€ ì¡°ì»¤ í„°ì¹˜ ì´ë²¤íŠ¸ ë³€ìˆ˜
        let blueJokerTouchStartTime = 0;
        let blueJokerTouchStartX = 0;
        let blueJokerTouchStartY = 0;
        let blueJokerIsTouchMoved = false;
        
        // íŒŒë€ ì¡°ì»¤ í´ë¦­ ì´ë²¤íŠ¸
        blueJoker.onclick = (e) => {
            // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                return;
            }
            addCardToPlayer('ğŸƒ', 'Blue', 'joker', 'blue');
        };
        
        // íŒŒë€ ì¡°ì»¤ í„°ì¹˜ ì‹œì‘
        blueJoker.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            blueJokerTouchStartTime = Date.now();
            blueJokerTouchStartX = touch.clientX;
            blueJokerTouchStartY = touch.clientY;
            blueJokerIsTouchMoved = false;
            
            // í„°ì¹˜ í”¼ë“œë°±
            blueJoker.style.transform = 'scale(1.1)';
        }, { passive: false });
        
        // íŒŒë€ ì¡°ì»¤ í„°ì¹˜ ì´ë™
        blueJoker.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const moveDistance = Math.sqrt(
                Math.pow(touch.clientX - blueJokerTouchStartX, 2) +
                Math.pow(touch.clientY - blueJokerTouchStartY, 2)
            );
            
            if (moveDistance > 10) {
                blueJokerIsTouchMoved = true;
                // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                blueJoker.style.transform = '';
            }
        });
        
        // íŒŒë€ ì¡°ì»¤ í„°ì¹˜ ì¢…ë£Œ
        blueJoker.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - blueJokerTouchStartTime;
            
            // í„°ì¹˜ í”¼ë“œë°± ì œê±°
            blueJoker.style.transform = '';
            
            // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì¹´ë“œ ì¶”ê°€
            if (touchDuration < 300 && !blueJokerIsTouchMoved) {
                addCardToPlayer('ğŸƒ', 'Blue', 'joker', 'blue');
            }
        }, { passive: false });
        
        const blueJokerCard = { suit: 'ğŸƒ', rank: 'Blue', type: 'joker', color: 'blue' };
        const blueJokerPath = getCardImagePath(blueJokerCard);
        blueJoker.style.backgroundImage = `url('${blueJokerPath}')`;
        blueJoker.style.backgroundSize = 'cover';
        blueJoker.style.backgroundPosition = 'center';
        blueJoker.style.backgroundRepeat = 'no-repeat';
        cardGrid.appendChild(blueJoker);
        
        const redJoker = document.createElement('div');
        redJoker.className = 'selectable-card';
        
        // ë¹¨ê°„ ì¡°ì»¤ í„°ì¹˜ ì´ë²¤íŠ¸ ë³€ìˆ˜
        let redJokerTouchStartTime = 0;
        let redJokerTouchStartX = 0;
        let redJokerTouchStartY = 0;
        let redJokerIsTouchMoved = false;
        
        // ë¹¨ê°„ ì¡°ì»¤ í´ë¦­ ì´ë²¤íŠ¸
        redJoker.onclick = (e) => {
            // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
            if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                return;
            }
            addCardToPlayer('ğŸƒ', 'Red', 'joker', 'red');
        };
        
        // ë¹¨ê°„ ì¡°ì»¤ í„°ì¹˜ ì‹œì‘
        redJoker.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            redJokerTouchStartTime = Date.now();
            redJokerTouchStartX = touch.clientX;
            redJokerTouchStartY = touch.clientY;
            redJokerIsTouchMoved = false;
            
            // í„°ì¹˜ í”¼ë“œë°±
            redJoker.style.transform = 'scale(1.1)';
        }, { passive: false });
        
        // ë¹¨ê°„ ì¡°ì»¤ í„°ì¹˜ ì´ë™
        redJoker.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const moveDistance = Math.sqrt(
                Math.pow(touch.clientX - redJokerTouchStartX, 2) +
                Math.pow(touch.clientY - redJokerTouchStartY, 2)
            );
            
            if (moveDistance > 10) {
                redJokerIsTouchMoved = true;
                // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                redJoker.style.transform = '';
            }
        });
        
        // ë¹¨ê°„ ì¡°ì»¤ í„°ì¹˜ ì¢…ë£Œ
        redJoker.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touchEndTime = Date.now();
            const touchDuration = touchEndTime - redJokerTouchStartTime;
            
            // í„°ì¹˜ í”¼ë“œë°± ì œê±°
            redJoker.style.transform = '';
            
            // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì¹´ë“œ ì¶”ê°€
            if (touchDuration < 300 && !redJokerIsTouchMoved) {
                addCardToPlayer('ğŸƒ', 'Red', 'joker', 'red');
            }
        }, { passive: false });
        
        const redJokerCard = { suit: 'ğŸƒ', rank: 'Red', type: 'joker', color: 'red' };
        const redJokerPath = getCardImagePath(redJokerCard);
        redJoker.style.backgroundImage = `url('${redJokerPath}')`;
        redJoker.style.backgroundSize = 'cover';
        redJoker.style.backgroundPosition = 'center';
        redJoker.style.backgroundRepeat = 'no-repeat';
        cardGrid.appendChild(redJoker);
    }
    
    function addCardToPlayer(suit, rank, type, color = null) {
        const card = { suit, rank, type };
        if (color) card.color = color;
        
        gameState.players[0].hand.push(card);
        updateUI();
        hideCardSelector();
    }
    

    
    function hideCardSelector() {
        document.getElementById('card-selector').style.display = 'none';
    }
        
        // ê²Œì„ ì‹œì‘
        function startNewGame() {
            
            // ê²Œì„ ì¢…ë£Œ íŒì—… ë‹«ê¸°
            const gameEndMessage = document.getElementById('game-end-message');
            if (gameEndMessage) {
                gameEndMessage.remove();
            }
            
            // ê²Œì„ ë©”ì‹œì§€ ì œê±°
            const gameMessage = document.getElementById('game-message');
            if (gameMessage) {
                gameMessage.remove();
            }
            
            // ì¹´ë“œ ì„ íƒê¸° ìˆ¨ê¸°ê¸°
            hideCardSelector();
            
            // ê²Œì„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
            gameState = {
                players: [
                    { id: 0, name: "í”Œë ˆì´ì–´", hand: [], isAI: false },
                    { id: 1, name: "AI Bot 1", hand: [], isAI: true },
                    { id: 2, name: "AI Bot 2", hand: [], isAI: true },
                    { id: 3, name: "AI Bot 3", hand: [], isAI: true }
                ],
                currentPlayer: 0,
                direction: 1, // 1: ì‹œê³„ë°©í–¥, -1: ë°˜ì‹œê³„ë°©í–¥
                deck: [],
                openDeck: [],
                currentSuit: 'â™ ï¸',
                currentRank: '7',
                attackStack: [], // ê³µê²© ì¹´ë“œë“¤ì„ ì €ì¥í•˜ëŠ” ë°°ì—´
                onecardButtonActive: false,
                onecardTimer: null,
                waitingForSuitSelection: false,
                suitSelectionPlayerIndex: -1,
                aiProcessing: false // AI ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€ í”Œë˜ê·¸
            };
            
            // ì›ì¹´ë“œ ë²„íŠ¼ ìˆ¨ê¸°ê¸°
            hideOnecardButton();
            
            // ë¬´ëŠ¬ ì„ íƒê¸° ìˆ¨ê¸°ê¸°
            hideSuitSelector();
            
            // UI ì´ˆê¸°í™”
            updateUI();
            
            // ìƒˆ ê²Œì„ ì‹œì‘
            initGame();
        }
        

        
        // í„°ì¹˜ ì´ë²¤íŠ¸ ì„¤ì •
        function setupTouchEvents() {
            // ë± í„°ì¹˜ ì´ë²¤íŠ¸
            const deckElement = document.getElementById('deck');
            if (deckElement) {
                let deckTouchStartTime = 0;
                let deckTouchStartX = 0;
                let deckTouchStartY = 0;
                let deckIsTouchMoved = false;
                
                // ë± í´ë¦­ ì´ë²¤íŠ¸
                deckElement.onclick = (e) => {
                    // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
                    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                        return;
                    }
                    drawCard();
                };
                
                // ë± í„°ì¹˜ ì‹œì‘
                deckElement.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    deckTouchStartTime = Date.now();
                    deckTouchStartX = touch.clientX;
                    deckTouchStartY = touch.clientY;
                    deckIsTouchMoved = false;
                    
                    // í„°ì¹˜ í”¼ë“œë°±
                    deckElement.style.transform = 'scale(1.1)';
                }, { passive: false });
                
                // ë± í„°ì¹˜ ì´ë™
                deckElement.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const moveDistance = Math.sqrt(
                        Math.pow(touch.clientX - deckTouchStartX, 2) +
                        Math.pow(touch.clientY - deckTouchStartY, 2)
                    );
                    
                    if (moveDistance > 10) {
                        deckIsTouchMoved = true;
                        // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                        deckElement.style.transform = '';
                    }
                });
                
                // ë± í„°ì¹˜ ì¢…ë£Œ
                deckElement.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - deckTouchStartTime;
                    
                    // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                    deckElement.style.transform = '';
                    
                    // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì¹´ë“œ ë½‘ê¸°
                    if (touchDuration < 300 && !deckIsTouchMoved) {
                        drawCard();
                    }
                }, { passive: false });
            }
            
            // ì›ì¹´ë“œ ë²„íŠ¼ í„°ì¹˜ ì´ë²¤íŠ¸
            const onecardButton = document.getElementById('onecard-button');
            if (onecardButton) {
                let onecardTouchStartTime = 0;
                let onecardTouchStartX = 0;
                let onecardTouchStartY = 0;
                let onecardIsTouchMoved = false;
                
                // ì›ì¹´ë“œ ë²„íŠ¼ í´ë¦­ ì´ë²¤íŠ¸
                onecardButton.onclick = (e) => {
                    // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
                    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                        return;
                    }
                    onecardCall();
                };
                
                // ì›ì¹´ë“œ ë²„íŠ¼ í„°ì¹˜ ì‹œì‘
                onecardButton.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    onecardTouchStartTime = Date.now();
                    onecardTouchStartX = touch.clientX;
                    onecardTouchStartY = touch.clientY;
                    onecardIsTouchMoved = false;
                    
                    // í„°ì¹˜ í”¼ë“œë°±
                    onecardButton.style.transform = 'scale(1.05)';
                }, { passive: false });
                
                // ì›ì¹´ë“œ ë²„íŠ¼ í„°ì¹˜ ì´ë™
                onecardButton.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const moveDistance = Math.sqrt(
                        Math.pow(touch.clientX - onecardTouchStartX, 2) +
                        Math.pow(touch.clientY - onecardTouchStartY, 2)
                    );
                    
                    if (moveDistance > 10) {
                        onecardIsTouchMoved = true;
                        // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                        onecardButton.style.transform = '';
                    }
                });
                
                // ì›ì¹´ë“œ ë²„íŠ¼ í„°ì¹˜ ì¢…ë£Œ
                onecardButton.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - onecardTouchStartTime;
                    
                    // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                    onecardButton.style.transform = '';
                    
                    // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ì›ì¹´ë“œ í˜¸ì¶œ
                    if (touchDuration < 300 && !onecardIsTouchMoved) {
                        onecardCall();
                    }
                }, { passive: false });
            }
            
            // ë¬´ëŠ¬ ì„ íƒ ì˜µì…˜ í„°ì¹˜ ì´ë²¤íŠ¸
            const suitOptions = document.querySelectorAll('.suit-option');
            suitOptions.forEach((option, index) => {
                const suits = ['â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸'];
                const suit = suits[index];
                
                let suitTouchStartTime = 0;
                let suitTouchStartX = 0;
                let suitTouchStartY = 0;
                let suitIsTouchMoved = false;
                
                // ë¬´ëŠ¬ ì„ íƒ í´ë¦­ ì´ë²¤íŠ¸
                option.onclick = (e) => {
                    // í„°ì¹˜ë¡œ ì¸í•œ í´ë¦­ì¸ ê²½ìš° ë¬´ì‹œ (í„°ì¹˜ ì´ë²¤íŠ¸ì—ì„œ ì²˜ë¦¬)
                    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) {
                        return;
                    }
                    selectSuit(suit);
                };
                
                // ë¬´ëŠ¬ ì„ íƒ í„°ì¹˜ ì‹œì‘
                option.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    suitTouchStartTime = Date.now();
                    suitTouchStartX = touch.clientX;
                    suitTouchStartY = touch.clientY;
                    suitIsTouchMoved = false;
                    
                    // í„°ì¹˜ í”¼ë“œë°±
                    option.style.transform = 'scale(1.1)';
                }, { passive: false });
                
                // ë¬´ëŠ¬ ì„ íƒ í„°ì¹˜ ì´ë™
                option.addEventListener('touchmove', (e) => {
                    const touch = e.touches[0];
                    const moveDistance = Math.sqrt(
                        Math.pow(touch.clientX - suitTouchStartX, 2) +
                        Math.pow(touch.clientY - suitTouchStartY, 2)
                    );
                    
                    if (moveDistance > 10) {
                        suitIsTouchMoved = true;
                        // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                        option.style.transform = '';
                    }
                });
                
                // ë¬´ëŠ¬ ì„ íƒ í„°ì¹˜ ì¢…ë£Œ
                option.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    const touchEndTime = Date.now();
                    const touchDuration = touchEndTime - suitTouchStartTime;
                    
                    // í„°ì¹˜ í”¼ë“œë°± ì œê±°
                    option.style.transform = '';
                    
                    // ì§§ì€ í„°ì¹˜ì´ê³  ì´ë™ì´ ì—†ìœ¼ë©´ ë¬´ëŠ¬ ì„ íƒ
                    if (touchDuration < 300 && !suitIsTouchMoved) {
                        selectSuit(suit);
                    }
                }, { passive: false });
            });
        }
        
        // ê²Œì„ ì‹œì‘
        window.onload = function() {
            startNewGame();
            setupTouchEvents();
        };
        

    </script>
</body>
</html> 